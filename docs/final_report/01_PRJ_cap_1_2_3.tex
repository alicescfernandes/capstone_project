%%________________________________________________________________________
%% LEIM | PROJETO
%% 2022 / 2013 / 2012
%% Modelo para relatório
%% v04: alteração ADEETC para DEETC; outros ajustes
%% v03: correção de gralhas
%% v02: inclui anexo sobre utilização aplicação controlo de versões
%% v01: original
%% PTS / MAR.2022 / MAI.2013 / 23.MAI.2012 (construído)
%%________________________________________________________________________


%%________________________________________________________________________
\chapter{Introdução}
\label{ch:introducao}
%%________________________________________________________________________

No contexto do ensino superior, tem-se dado cada vez mais importância à integração de ferramentas tecnológicas que tornem o processo de aprendizagem mais prático, como é o caso do simulador utilizado pelos alunos do \gls{iscal}. Esta ferramenta permite que os estudantes apliquem, de forma interativa, os conhecimentos adquiridos ao longo do curso, colocando-os em situações de tomada de decisão semelhantes às que enfrentariam num ambiente real. Deste modo, o simulador não só reforça os conteúdos teóricos, como também reforça o desenvolvimento das competências aprendidas. 

Neste contexto, a análise eficiente de dados torna-se essencial para a tomada de decisões e tem impacto na avaliação final dos alunos, no entanto, a complexidade e a falta de uma ferramenta visual que ajude a perceber as informações apresentadas pode representar um desafio grande para os estudantes.

\section{Motivação}

O presente projeto surgiu da necessidade  entre os alunos do \gls{iscal} que utilizam o simulador \textit{International Corporate Management} da empresa \textit{Marketplace Simulations}, que é um simulador de negócios internacionais e que iremos descrever no capítulo~\ref{sec:marketplace}, onde os alunos agrupam-se em empresas e simulam um negócio num mercado internacional. Embora a plataforma apresente toda a informação necessária à tomada de decisões na simulação, esses dados estão espalhados em múltiplas páginas e apresentados em tabelas, com poucas funcionalidades de visualização. Esta limitação obriga os alunos a alternar entre páginas, copiar dados manualmente ou criar folhas de cálculo externas, comprometendo a eficiência e a análise da informação.

\section{Objetivos}

A aplicação proposta neste relatório pretende ajudar nesse sentido, disponibilizando uma interface que permite aos utilizadores carregar dados retirados da plataforma de simulação e tornar esses ficheiros em visualizações que podem ser consultadas e manipuladas. A aplicação permitirá aos utilizadores:

\begin{itemize}
    \item Criar uma conta na plataforma que suporte a persistência da informação carregada.
    \item Carregar ficheiros exportados da plataforma de simulação.
    \item Visualizar os dados em gráficos interativos.
    \item Conseguir ter uma experiência de utilização intuitiva e fácil.
\end{itemize}

Pretende-se também que a aplicação adote uma arquitetura simples de manter e que utilize os mesmos conceitos que a plataforma de simulação, dando importância aos seguintes itens:

\begin{itemize}
    \item Normalização e transformação automática de dados carregados.
    \item Facilidade na gestão de ficheiros, com o objetivo de oferecer uma interface intuitiva para os utilizadores finais.
    \item Organizar a informação por utilizador, garantindo que cada utilizador apenas consegue consultar a sua informação carregada.
    \item Adotar um modelo de funcionamento semelhante à plataforma de simulação, de modo a tornar a utilização mais fácil e garantir que a nossa aplicação tenha fronteiras claras de utilização.
\end{itemize}

Ao longo deste relatório, serão apresentadas as decisões tomadas, bem como os fundamentos que orientaram o desenvolvimento da aplicação proposta.

%%________________________________________________________________________
\chapter{Trabalho Relacionado}
\label{ch:trabalhoRelacionado}
%%________________________________________________________________________

O presente projeto insere-se num contexto mais geral de ferramentas pedagógicas e de \gls{sad}, ainda que neste caso concreto, em ambientes simulados no ensino superior. No âmbito do \gls{iscal}, a utilização da plataforma \textit{Marketplace Simulations} \cite{MarketplaceSim_2025} permite aos estudantes desenvolver competências práticas em ambientes virtuais de negócios, simulando o funcionamento de mercados reais. A necessidade de suporte digital à análise e simulação motivou o desenvolvimento de outras ferramentas auxiliares, com destaque para um projeto também realizado em parceria com o \gls{iscal}, focado em simulações parciais de modelos económicos.

Esse projeto, embora partilhe uma motivação semelhante, segue uma abordagem diferente. Em particular, a aplicação referida acima permite simular cenários específicos com base em \textit{inputs} manuais, o que pode ser útil para quando se procura prever resultados com foco muito concreto (por exemplo, simular o impacto de uma única variável nos resultados). A nossa plataforma foca-se numa outra vertente, em que pretende ser uma ferramenta para auxiliar o ensino de forma prática.

O projeto assume então o uso de dados extraídos diretamente da plataforma de simulação, e a valorização da experiência do utilizador na apresentação de dados. Não será uma plataforma de simulação, mas sim uma ferramenta para auxiliar o ensino de forma prática.

\noindent \textbf{Sistemas de apoio à decisão}
\label{sec:sad}

Um \gls{sad} é uma aplicação, ou um conjunto de aplicações, pensadas para ajudar utilizadores a tomar decisões mais informadas. Ao contrário de sistemas que tomam decisões de forma autónoma, um \gls{sad} funciona como uma ferramenta que mostra aos utilizadores os dados e análises para que estes possam avaliar alternativas, prever resultados e escolher a melhor ação possível.

Na prática, um \gls{sad} é responsável por recolher, organizar e processar grandes volumes de dados, muitas vezes com origem em várias fontes, e transformá-los em informação relevante. Esta informação é normalmente apresentada através de tabelas, indicadores ou representações visuais como gráficos de barras. Um aspeto importante é a capacidade de aplicar filtros e explorar diferentes cenários, o que permite ao utilizador testar hipóteses, identificar padrões e comparar dados.

Estes sistemas são particularmente úteis em contextos onde há grande complexidade como por exemplo, na gestão empresarial, em análises financeiras, ou na análise de mercados. Num ambiente académico, como é o caso da plataforma usada neste projeto, um \gls{sad} ajuda os estudantes a perceber que decisões tomar, mostrando dados históricos para que possam ser identificadas tendências ou padrões.

É importante reforçar que o \gls{sad} não substitui o utilizador. Em vez disso, aumenta a capacidade do utilizador de interpretar a informação disponível e tomar decisões, reduzindo o risco de erro e aumentando a confiança. Estes sistemas podem ser plataformas criadas especificamente para o efeito, ou podem ser derivadas de outras plataformas como \textit{PowerBI}, \textit{Tableau}, \textit{Grafana}, ou outras ferramentas de visualização de dados.

%%________________________________________________________________________
\chapter{Modelo Proposto}
\label{ch:modeloProposto}
%%________________________________________________________________________

Neste capítulo vamos descrever o modelo que serviu de base à implementação da aplicação, com foco na forma como os dados são organizados, processados e apresentados ao utilizador. A estrutura proposta resulta das necessidades identificadas durante a análise dos ficheiros obtidos da plataforma de simulação, bem como dos requisitos definidos com os orientadores do projeto.

O modelo tem como objetivo garantir que a aplicação desenvolvida corresponde as necessidades identificadas. Para isso, foram definidos vários requisitos, e foi estudado como iriamos apresentar os dados tendo em conta os ficheiros recebidos, entre outras decisões que foram tomadas durante o desenvolvimento do projeto.

Nos próximos parágrafos vamos então detalhar cada uma das partes do modelo proposto, começando pelos requisitos funcionais e não funcionais que foram definidos.

%%________________________________________________________________________
\section{Requisitos}
\label{sec:requisitos}
%%________________________________________________________________________

\subsubsection{Requisitos funcionais}

Os requisitos funcionais descrevem as funcionalidades obrigatórias que a aplicação deve oferecer aos utilizadores. No contexto deste projeto, definem as ações que a aplicação deve ser capaz de executar.

Para o projeto, identificamos os seguintes requisitos, ordenados por prioridade. Os tabelas de requisitos por inteiro, incluindo algumas definições adicionais, estão incluídas em apêndice \ref{ch:tabRequisitos}.

\begin{itemize}
    \item \textbf{Visualização de dados:} O utilizador deve poder visualizar gráficos interativos baseados nos dados carregados, com a possibilidade de aplicar filtros como país ou \textit{quarter} selecionado.

    \item \textbf{Gestão de ficheiros:} O utilizador deve poder carregar ficheiros, associá-los a \textit{quarters} e eliminá-los quando necessário. A aplicação valida os formatos e garante que apenas ficheiros válidos são tratados.
    
    \item \textbf{Gestão de \textit{quarters}:} O utilizador deve poder criar períodos, identificados como \textit{Quarter N}, para organizar os ficheiros carregados. Tem também de ser possível visualizar a lista de \textit{quarters} disponíveis.

    \item \textbf{Autenticação:} O utilizador deve poder criar uma conta e usar autenticar com a conta criada. Os dados apresentados devem ser apenas os do utilizador autenticado.

    \item \textbf{Normalização de dados:} Os dados extraídos dos ficheiros devem ser automaticamente normalizados para garantir consistência e compatibilidade com a aplicação.
    
\end{itemize}

\subsubsection{Requisitos não funcionais}

Alguns requisitos não funcionais também foram importantes para garantir a estabilidade e a capacidade de interação da aplicação. Os requisitos identificados foram os seguintes:

\begin{itemize}
    \item \textbf{Usabilidade:} A aplicação deve ser intuitiva, suportar múltiplos \textit{browsers} e permitir o carregamento progressivo de gráficos sem bloquear a interface visual (\textit{lazy load}).
    
    \item \textbf{Performance:} A aplicação deve ser capaz de suportar múltiplos utilizadores em simultâneo, mantendo uma resposta rápida às interações.
    
    \item \textbf{Acessibilidade:} A aplicação deve ser acessível por teclado e compatível com leitores de ecrã (\textit{screen-reader friendly}).

\end{itemize}

\section{Casos de Utilização}
\label{ch:casosUtilizacao}

Com base nos requisitos funcionais e não funcionais identificados na secção~\ref{sec:requisitos}, foram definidos os casos de utilização que iremos suportar. A figura~\ref{fig:umlCasosUtilizacao} apresenta o diagrama \gls{uml} dos casos de utilização da aplicação. Este diagrama ilustra as interações entre os vários atores que fazem parte da aplicação.

\begin{figure}[h]
\centering
\includegraphics[max width=\textwidth]{./img/usecase_uml}
\caption{\gls{uml} dos Casos de Utilização}
\label{fig:umlCasosUtilizacao}
\end{figure}

Na figura~\ref{fig:umlCasosUtilizacao} podemos ver os atores e os casos de utilização da aplicação, que são os seguintes:
\begin{itemize}
    \item \textbf{Utilizador} É o ator principal, responsável por interagir com a aplicação. Pode criar conta, iniciar sessão, carregar ficheiros, visualizar gráficos, entre outras ações.
    \item \textbf{Base de Dados (DB)} Responsável por armazenar dados dos ficheiros carregados e metadados associados, e os \textit{quarters} criados pelo utilizador.
    \item \textbf{Sistema de Ficheiros} Responsável pelo armazenamento físico dos ficheiros carregados.
\end{itemize}


Temos também definidos os seguintes casos de utilização, que descrevemos com algum detalhe:
\begin{itemize}
    \item \textbf{Criar e gerir \textit{quarters}:} Permite ao utilizador, após autenticação, criar \textit{quarters}. Cada \textit{quarter} é identificado por um número (único por utilizador) e guardado na base de dados, sendo associado a um \gls{uuid} para efeitos internos.

    \item \textbf{Carregar ficheiros:} O utilizador seleciona um \textit{quarter} e carrega ficheiros exportados da plataforma de simulação. A aplicação valida os ficheiros, extrai e processa cada folha de cálculo e aplica a \textit{pipeline} de normalização. Os dados normalizados são armazenados e associados ao \textit{quarter} correspondente.

    \item \textbf{Eliminar ficheiros:} Permite ao utilizador remover ficheiros que foram carregados. A aplicação atualiza os registos no \textit{backend}, marca os dados antigos como não correntes e evita que sejam considerados nos gráficos, garantindo que apenas uma versão está ativa por ficheiro.

    \item \textbf{Normalizar dados:} Sub-processo automático executado durante o carregamento de ficheiros. Converte os dados para um formato estruturado através de uma \textit{pipeline} de normalização. Comunica com a base de dados e a aplicação de ficheiros.

    \item \textbf{Consultar gráficos:} Após o carregamento dos ficheiros, o utilizador pode consultar gráficos com base nos ficheiros carregados. A aplicação permite aplicar filtros, navegar entre \textit{quarters} e ver gráficos.

    \item \textbf{Criar conta:} Permite o registo de novos utilizadores. A aplicação valida os dados inseridos, verifica se o utilizador já existe e cria a conta, autenticando automaticamente o utilizador após sucesso.

    \item \textbf{Iniciar e Terminar sessão:} O utilizador introduz credenciais válidas (\textit{username} e \textit{password}) e, caso sejam corretas, é autenticado e redirecionado para a interface principal. Este processo inclui a gestão da sessão.

\end{itemize}

%%________________________________________________________________________
\section{Fundamentos}
\label{sec:fundamentos}

Neste capitulo iremos descrever as bases nas quais fundamentamos o projeto, e algumas noções necessárias para conseguir contextualizar as decisões tomadas.

\subsection{\textit{Marketplace Simulations}}
\label{sec:marketplace}

A \textit{Marketplace Simulations} \cite{MarketplaceSim_2025} é uma empresa que desenvolve plataformas de simulação para fins educativos, ou seja, ferramentas que colocam os estudantes numa espécie de jogo onde cada equipa gere a sua própria empresa e compete com os colegas em cenários simulados. Acabam então por funcionar como laboratórios virtuais que podem ser usados no ensino superior, onde os alunos aplicam os conceitos aprendidos numa experiência em contexto educativo.

No caso concreto do projeto, a aplicação em questão chama-se \textit{International Corporate Management} (referida neste relatório como plataforma de simulação), e é utilizada tipicamente no último semestre, na cadeira Projeto de Simulação em Negócios Internacionais da Licenciatura de Comércio e Negócios Internacionais \cite{FUC_ISCAL_2025}, que tem a interface apresentada na figura \ref{fig:marketplace1}.

\begin{figure}[h]
    \centering
    \includegraphics[max width=\textwidth]{./img/marketplace1}
 \caption{Captura de ecrã da aplicação \textit{International Corporate Management}}
 \label{fig:marketplace1}
 \end{figure}

Nesta plataforma, cada grupo de alunos representa uma empresa que tem de atuar num mercado internacional, tomando decisões sobre o posicionamento de produto, investimento, preços, distribuição, entre outras opções. Essas decisões são processadas pela plataforma, que simula o comportamento do mercado com base num algoritmo interno. 

A evolução temporal da simulação é dada por \textit{quarters}, que representam uma semana simulada. No final de cada \textit{quarter}, os alunos recebem os dados com os resultados das decisões anteriores, o que obriga a uma análise comparativa entre períodos. É este ciclo (decidir, analisar, ajustar, repetir) que dá sentido à simulação e aproxima o exercício a uma situação real.

A simulação está dividida em secções, cada uma representando uma área distinta do negócio gerido pelos alunos. Estas secções agrupam métricas, decisões ou outras informações relacionadas com aspetos específicos da empresa simulada, como por exemplo a procura por segmento, o desempenho financeiro, a perceção da marca ou a eficácia da equipa de vendas.

Cada secção representa também uma área onde os alunos têm de tomar decisões. As decisões variam consoante o tipo de secção, como por exemplo, na secção \textit{Customer Needs}, os alunos devem decidir que segmentos pretendem servir e com que marcas. Estas decisões são submetidas no final de cada \textit{quarter}, influenciando os resultados do seguinte periodo, que por sua vez geram novos dados para análise.

A plataforma \textit{International Corporate Management} permite exportar os dados de cada secção em ficheiros \textit{Excel}, sendo que cada ficheiro está associado a uma destas secções como por exemplo a secção\textit{Customer Needs}, entre outras.

Para a análise, os alunos têm à disposição os dados, na plataforma, nas várias secções disponiveis que na sua maioria são apresentados em tabelas, o que faz com que os alunos saltem entre secções, ou tenham de fazer gráficos à mão ou em último caso, extrair a informação da plataforma, não sendo então prático analisar a informação só pela plataforma de simulação.

Esta plataforma apresenta outros desafios, não é de código aberto pelo que não dá para perceber os seus algoritmos internos e só no contexto da unidade curricular é que se percebe o seu propósito, tornando dificil explicar o seu funcionamento fora do contexto da unidade curricular.

\subsection{\textit{Pipelines Extract, Transform Load}}
\label{ch:etl}

Uma \textit{pipeline} \gls{etl} é um processo utilizado em sistemas de tratamento e integração de dados, com o objetivo de mover dados de uma ou mais fontes para um destino, geralmente uma base de dados ou plataformas específicos para a análise de dados \cite{vassiliadis2009survey}. Uma \textit{pipeline} \gls{etl} é composta por três fases principais:

\begin{itemize}
  \item \textit{Extract} (Extrair): Consiste em recolher os dados das fontes de informação, que podem incluir bases de dados relacionais, APIs externas, sensores, entre outros. Esta fase preocupa-se com a capacidade de ler dados e de confirmar que são possíveis de extrair.  Exemplos de ferramentas que podem ser utilizadas nesta fase incluem o \textit{Apache NiFi} \cite{apache_nifi}, \textit{Fivetran} \cite{fivetran}, \textit{Airbyte} \cite{airbyte} e o \textit{Google Cloud Dataflow} \cite{dataflow}.
  
  \item \textit{Transform} (Transformar): Nesta fase os dados extraídos são processados e convertidos num formato mais adequado ao destino. Isso pode incluir tarefas como limpeza de dados (remoção de valores nulos ou duplicados), normalização, mudanças de tipo, ou cálculos. É nesta fase em que se garante a consistência da informação. Ferramentas populares para transformação incluem o \textit{dbt (data build tool)} \cite{dbt}, o \textit{Apache Beam} \cite{apache_beam} (usado com \textit{Dataflow}) e o \textit{Apache Spark} \cite{apache_spark}.

  \item \textit{Load} (Carregar): Por fim, os dados transformados são inseridos na aplicação de destino, normalmente um \textit{data warehouse},  O carregamento é feito dependendo dos requisitos da aplicação de destino. Exemplos de produtos que podem ser utilizados como destino são bases de dados como \textit{BigQuery} \cite{bigquery}, \textit{Snowflake} \cite{snowflake}, \textit{Clickhouse} \cite{clickhouse}, entre outros.

\end{itemize}

As \textit{pipelines} \gls{etl} são muito utilizadas em contextos onde há necessidade de consolidar dados de várias origens, permitindo análises mais completas. São fundamentais em áreas como \textit{business intelligence}, ciência de dados e integração de sistemas.


\subsection{Padrão Cliente-Servidor}

O projeto desenvolvido segue uma arquitetura de aplicações cliente-servidor, dividida em duas grandes camadas: \textit{backend} e \textit{frontend}.

\textbf{\textit{Backend}}

O \textit{backend} corresponde a ```parte invisível” da aplicação, ou seja, tudo o que acontece do lado do servidor. É a camada responsável por tratar os dados, executar a lógica de negócio e responder aos pedidos efetuados pelos utilizadores. No contexto específico deste projeto, o \textit{backend} é responsável por:

\begin{itemize}
    \item carregamento de ficheiros;
    \item processamento e normalização dos dados;
    \item autenticação e gestão de sessões;
    \item disponibilização de uma \gls{api} para o \textit{frontend} que permita acesso aos dados.
\end{itemize}

\textbf{Frontend}

O \textit{frontend} corresponde à ``parte visível'' da aplicação, ou seja, aquilo que o utilizador vê e com que interage no \textit{browser}. É a camada responsável por apresentar a informação de forma clara e permitir a interação com as funcionalidades disponibilizadas pela aplicação. No contexto deste projeto, o \textit{frontend} é responsável por:
\begin{itemize}
    \item os formulários, utilizados por exemplo para autenticação, criação de trimestres e envio de ficheiros;
    \item os gráficos que são apresentados ao utilizador, com os dados processados pelo \textit{backend};
    \item e outros elementos visuais criados a partir dos dados processados, como mensagens de erro, modais, entre outros.
\end{itemize}

Esta separação facilita a manutenção da aplicação e permite que ambas as partes sejam desenvolvidas de forma independente, podendo até ser substituídas sem necessidade de reescrever a aplicação completo. As tecnologias utilizadas para o desenvolvimento serão descritas no capítulo \ref{sec:tec}.

\subsection{Tipos de gráficos}

Durante a análise efetuamos foram estudados diferentes tipos de visualizações que podiam ser aplicadas, de acordo com os dados que tínhamos disponíveis. Cada tipo de visualização foi escolhido com base na sua capacidade de representar visualmente os dados e a sua facilidade de interpretação.  Consideramos então vários tipos de visualizações gráficas. 

Importa salientar que as imagens que acompanham esta secção foram retiradas diretamente da aplicação desenvolvida, já tendo em conta as limitações e as transformações realizadas nos dados. Estas transformações são discutidas mais a fundo no capítulo~\ref{sec:analiseInicial}.

\textbf{Gráfico de Barras (\textit{Bar Chart}):}

Este tipo de visualização foi utilizado para comparar valores entre diferentes categorias, como marcas, cidades ou segmentos de mercado. A disposição visual das barras permite uma leitura rápida das diferenças de desempenho entre categorias, sendo útil para dados que não são temporais. Foi também utilizado a variante barras agrupadas, dependendo se havia necessidade de comparar valores entre categorias.


\begin{figure}[H]
\centering
\includegraphics[max width=10cm]{./img/barras1}
\caption{Exemplo de gráfico de barras}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[max width=10cm]{./img/agrupada}
\caption{Exemplo de gráfico de barras agrupadas}
\end{figure}

\textbf{Gráfico de Sectores (\textit{Pie Chart}):}  

Utilizado para representar distribuições percentuais, como partições de dados por segmento. Este tipo é de gráfico é intuitivo para visualizar como uma totalidade se divide entre diferentes partes, sendo apropriado para dados onde se pretendia mostrar proporções relativas (como por exemplo dados categorizados por segmentos)

\begin{figure}[H]
    \centering
    \includegraphics[max width=10cm]{./img/pie}
    \caption{Exemplo de gráfico de sectores}
\end{figure}

\textbf{Gráfico Financeiro (\textit{Waterfall Chart}):}  

Utilizado especificamente para representar balanços financeiros, como valores acumulados de receitas e despesas. Permite também visualizar como diferentes contribuições individuais afetam um valor final, facilitando a análise de ganhos e perdas.

\begin{figure}[H]
    \centering
    \includegraphics[max width=10cm]{./img/waterfall}
    \caption{Exemplo de gráfico financeiro}
\end{figure}

\textbf{Diagrama de Quartis (\textit{Box Plot}):}

Os diagramas de quartis foram utilizados para representar dados que eram distribuições com mínimos e máximos, permitindo visualizar de forma prática a mediana, os quartis e valores extremos.  A interpretação deste tipo de visualização exige um conhecimento prévio de conceitos estatísticos como mediana e quartis, o que pode dificultar a leitura, mas que simplifica a representação dos dados.

\begin{figure}[H]
    \centering
    \includegraphics[max width=10cm]{./img/box}
    \caption{Exemplo de diagrama de quartis}
\end{figure}

\textbf{Diagrama de Sankey (\textit{Sankey Diagram}):}

Os diagramas de \textit{Sankey} são utilizados para representar fluxos entre diferentes categorias, sublinhando a quantidade transferida de uma categoria para outra. Cada fluxo é representado por uma linha cuja largura é proporcional à quantidade movida, permitindo uma visualização intuitiva da importância dos fluxos. Para evitar representações complexas, decidimos apenas recorrer a este tipo apenas quando os dados não poderiam ser representados de outra forma, ou tratados de forma a simplificar a representação.

\begin{figure}[H]
    \centering
    \includegraphics[max width=10cm]{./img/skankey}
    \caption{Exemplo de gráfico de \textit{Sankey}}
\end{figure}

Outros tipos de gráficos relevantes para o projeto, mas que não foram utilizados são:

\textbf{Gráfico de Linhas (\textit{Line Chart}):}  

Escolhido para representar séries temporais, como a evolução de uma variável ao longo do tempo. As linhas permitem identificar tendências e variações. No projeto, não tivemos necessidade de usar este tipo uma vez que nenhum dos dados recebidos era relativos a séries temporais, pelo que a sua utilização não era intuitiva para os utilizadores nem resultava numa visualização que fizesse sentido para os dados recebidos.

\textbf{Gráfico de Radar (\textit{Radar Chart}):}  

Utilizado para comparar múltiplas variáveis em relação a um valor comum, como no caso da avaliação de diferentes necessidades dos clientes em simultâneo. Este tipo de gráfico permite identificar rapidamente pontos fortes e fracos em várias dimensões de análise. Apesar destas vantagens, nos dados que recebemos não conseguimos identificar utilizações onde este tipo de gráfico beneficiasse os utilizadores finais.

\textbf{Gráfico de Dispersão (\textit{Scatter Plot}):}

Os gráficos de dispersão foram considerados para representar relações entre duas variáveis. Cada ponto no gráfico representa uma observação individual, permitindo identificar padrões de correlação (positiva, negativa ou inexistente) entre variáveis. No nosso caso, consideramos utilizar um tipo específico de gráfico de dispersão (gráfico de dispersão num mapa) mas a leitura tornou-se confusa, uma vez que era pouco legível para alunos, e não considerava localizações fictícias, fazendo com que a leitura fosse difícil.

A escolha dos tipos de gráficos teve como objetivo manter a clareza e facilidade da informação e permitir diferentes leituras sobre os dados extraídos. Cada gráfico foi pensado para às características dDOS dados disponiveis, considerando o formato dos dados (quantitativa ou categórica) e o objetivo da análise (comparação, distribuição, evolução ou composição).

%%________________________________________________________________________
\section{Abordagem}
\label{sec:abordagem}
%%________________________________________________________________________

O projeto proposto pretende então conseguir transformar dados desta plataforma em algo mais fácil e rápido de analisar. Tendo o contexto da plataforma, iremos então descrever duas abordagens que considerámos.

\subsection{\textit{Web \textit{scraping}}}

A primeira abordagem que consideramos foi a hipótese de automatizar a extração dos dados diretamente da plataforma do \textit{Marketplace Simulations}, através de técnicas de \textit{web} \textit{scraping}. A ideia parecia interessante numa fase inicial, já que permitiria reduzir a dependência do utilizador no processo de exportação  dos dados. No entanto, rapidamente percebemos que esta abordagem trazia vários desafios que, na prática, a tornavam pouco viável, ou mesmo arriscada.

Primeiro, cada conta na plataforma está associada a um grupo de alunos, ou seja, é uma conta ativa e única, usada diretamente durante a simulação. Isto significa que qualquer processo automático que iniciasse sessão, mesmo que fosse só para leitura, poderia de forma acidental interagir com a interface e acabar por alterar alguma opção, o que poderia comprometer a avaliação dos alunos porque podia afetar a sua avaliação final. Além disso, como o acesso à plataforma é feito por licenças pagas, não existe qualquer possibilidade de criar uma conta de serviço ou utilizador apenas para leitura. Ou seja, qualquer tentativa de \textit{web} \textit{scraping} teria de reutilizar credenciais reais, o que levanta não só questões de segurança, mas também (possivelmente) legais, uma vez que a plataforma pode não permitir o \textit{web} \textit{scraping}.

Outro fator que influenciou a nossa decisão foi o próprio risco técnico do \textit{web} \textit{scraping} uma vez que plataformas deste tipo estão muitas vezes protegidas com mecanismos contra automação (como por exemplo ecrãs CAPTCHA), e não conhecendo em detalhe a aplicação, poderíamos facilmente encontrar esse tipo de proteções, que são difíceis de automatizar.

Pelos motivos acima, optámos por não seguir esta abordagem. Em vez disso, definimos como parte da utilização da nossa aplicação que os próprios alunos devem exportar dados a partir da plataforma de simulação e carregar para a nossa aplicação. Esta solução, embora mais manual, garante segurança, respeita a integridade das contas dos utilizadores, e evita problemas legais ou técnicos com a aplicação de simulação.

\subsection{Exportação e carregamento manual de ficheiros}

A abordagem que acabamos por usar foi os alunos exportam manualmente os dados diretamente da plataforma de simulação e carregarem esses ficheiros na nossa plataforma. A partir daí, a aplicação processa e normaliza os dados recebidos, e mostra gráficos com base nesses dados. Esta abordagem, apesar de requerer uma ação manual do lado do utilizador, é mais segura que a alternativa de \textit{web} \textit{web} \textit{scraping}, pelos os motivos apresentados acima. Deste modo, garantimos um equilíbrio entre usabilidade, segurança e fiabilidade da aplicação. Acabamos então por criar um \gls{sad} (\cf, capítulo \ref{sec:sad}) que permita os estudantes tomarem melhores decisões.

Com esse objetivo, procurámos que a nossa aplicação refletisse a estrutura da própria simulação. Como tal, os dados são organizados por \textit{quarters}, como acontece na plataforma de simulação e permitir o carregamento dos dados exportados. Estes ficheiros são depois processados o que nos permite trabalhar com dados mais consistentes. 

Esta estrutura base implica a existência de três entidades principais na nossa aplicação (que iremos descrever nos capítulos seguintes) e cuja interação define  o funcionamento da aplicação.

\subsubsection{\textit{Quarters}}

Os \textit{quarters} funcionam como \textit{buckets} para organizar os ficheiros carregados pelos utilizadores. Cada utilizador pode criar múltiplos \textit{quarters}, identificados de forma única por um número. O propósito em incluir este conceito é para que a aplicação consiga associar os dados extraídos dos ficheiros carregados ao \textit{quarter} correspondente sem depender de manipulações do nome do ficheiro carregado, e desde modo assegurar que a plataforma consegue identificar corretamente os \textit{quarters}. 

A desvantagem é que requer \textit{input} do utilizador para que seja criado ou atribuído o \textit{quarter} correto. De modo a facilitar a criação de \textit{quarters}, tentamos que experiência de utilização fosse centrada no carregamento de ficheiros, limitando os \textit{quarters} a um campo obrigatório no formulário de carregamento auto-preenchido, ou seja, tornando implícita a criação de \textit{quarters} no momento de carregamento de ficheiros.

\subsubsection{Ficheiros}

Os ficheiros são inicialmente carregados no formato \gls{xlsx} (que é o formato que a plataforma de simulação exporta), contendo uma ou várias folhas de cálculo. Cada folha é tratada como uma fonte de dados individual e é de onde são extraídos os dados. O ficheiro \gls{xlsx} é guardado como referência, mas não é diretamente utilizado para visualização, ficando apenas como artefacto interno da aplicação. O modelo proposto apenas considera um gráfico por folha de cálculo.

O processamento que é aplicado é uma \textit{pipeline} de transformação de dados (conhecido na indústria como \gls{etl} (\cf, capítulo \ref{ch:etl})), que aplica regras para que os gráficos possam ser mostrados de forma consistente. Os dados resultantes desta transformação estão associados ao ficheiro \gls{xlsx} original, sendo até possível voltar a processar ficheiros de forma a recriar informação (esta funcionalidade não é disponibilizada aos utilizadores finais e não foi desenvolvida de forma explícita).

A aplicação garante que só existe uma versão ativa de cada ficheiro. Caso o utilizador carregue novamente um ficheiro com o mesmo nome, o anterior será marcado como não ativo, evitando duplicações e garantindo que os gráficos usam apenas dados mais recentes, e em caso de remoção, garante que conseguimos reverter para a versão anterior.

\subsubsection{\textit{Pipeline} de Transformação de Dados}

Para conseguirmos então garantir uma experiência de utilização consistente, desenvolvemos uma \textit{pipeline} transformação de dados, semelhante a uma \textit{pipeline} \gls{etl} (\cf, capítulo \ref{ch:etl}), ainda que neste projeto tenha sido desenvolvido com uma escala mais pequena, e com recurso a bibliotecas de processamento de dados. 

O objetivo é garantir que os ficheiros carregados, que muitas vezes contêm nomes de colunas inconsistentes, quebras de linha, espaços em excesso ou colunas irrelevantes, sejam adaptados para serem visualizados, e que o processamento seja determinístico.

Como podemos receber muitos ficheiros, a variabilidade entre os dados recebidos é muito alta, pelo que alguns dados passam por mais do que uma fase de transformação. Esta decisão foi tomada com base numa análise manual, em que identificámos possíveis fontes de dados que precisam de mais do que uma fase de transformação. As várias fases de transformação alteram os dados de modo a facilitar a representação visual dos mesmos e é um passo essencial no projeto, porque garante que a aplicação trabalha com formatos e regras conhecidas, e remove a variabilidade dos ficheiros importados. Para proteger a aplicação, decidimos apenas mostrar os dados que foram extraídos de ficheiros conhecidos, de modo a garantir a consistência dos dados mostrados.

As fases de transformação irão ser descritas em mais detalhe nos capítulos seguintes, uma vez que a implementação destas pipeline estão relacionadas à tecnologia escolhida, mas o desenvolvimento desta \textit{pipeline} é um fator diferenciador deste projeto, uma vez que tem de lidar com dados que não estão estruturados de forma a facilitar representações visuais. 

\subsubsection{Utilizadores}

A aplicação foi projetada para funcionar com utilizadores. Cada utilizador tem a sua conta, e pode criar \textit{quarters}, carregar ou alterar ficheiros, e ver aos gráficos criados a partir desses ficheiros.

Apesar da aplicação não suportar explicitamente grupos, assume-se que alunos do mesmo grupo podem carregar ficheiros semelhantes, mas a aplicação trata-os como ficheiros diferentes. Assim, evita-se a complexidade adicional de gerir permissões ou partilha de dados entre contas.  Também se assume que as contas podem ser criadas ao nível do grupo, pelo que para a aplicação, é indiferente se a conta é individual ou partilhada entre membros desse grupo.

Cada utilizador tem acesso apenas aos seus próprios dados, garantindo o isolamento da informação. Esta separação é feita a nível da base de dados, através da associação de cada entidade (ficheiro ou \textit{quarter}) ao utilizador que criou.

No futuro, pode ser considerada a funcionalidade de desativação automática de contas (por exemplo, após o final do semestre) ou a gestão das contas por um docente da unidade curricular.

No próximo capitulo iremos então descrever as escolhas tomadas de forma a concretizar este modelo.

\section{Arquitetura e Tecnologias Adotadas}
\label{sec:tec}

\begin{figure}[h]
\centering
\includegraphics[max width=\textwidth]{./img/arch}
\caption{Arquitetura da aplicação}
\label{fig:arquitectura}
\end{figure}

A arquitetura final da aplicação pode ser observada na Figura~\ref{fig:arquitectura}. Esta segue o modelo cliente-servidor, onde os utilizadores interagem com a aplicação através de um \textit{browser}. A escolha das tecnologias baseou-se na familiaridade prévia com cada uma, na maturidade da mesma, as respetivas comunidades, bem como o contexto e requisitos do projeto. Nas seguintes secções especificamos que tecnologias escolhemos e que funções desempenham na aplicação.

\subsection{Django}

Para o desenvolvimento do \textit{backend} da aplicação, optámos por usar a \textit{framework} \textit{Django}. A escolha deveu-se ao facto de o \textit{Django} ser uma \textit{framework} muito usada, com uma arquitetura conhecida e uma comunidade muito grande.

Uma das principais vantagens do \textit{Django}\cite{djangodocs} é o facto de seguir uma variante do padrão \gls{mvc}, conhecida como \gls{mtv},  o que facilita bastante a organização da aplicação e a separação de responsabilidades.

\begin{itemize}
    \item o \textit{Model} representa a camada de dados e corresponde ao modelo do domínio;

    \item o \textit{Template} representa a camada de apresentação (interface com o utilizador);

    \item a \textit{View} é a camada intermediária que processa a lógica da aplicação e interage com as outras camadas.
\end{itemize}

Para além disso, o \textit{Django} utiliza um \gls{orm}, que permite interagir com bases de dados sem necessidade de escrever \gls{sql} manualmente. Este \gls{orm} mapeia os modelos para entidades na base de dados e suporta operações como filtros, agregações e relações entre tabelas \cite{djangodocs}, e ao mesmo tempo previne falhas de segurança, como \textit{SQL injection}, através do uso de consultas parametrizadas \cite{kumar2016security}.

Outra vantagem é a as funcionalidades gestão de utilizadores e sessões já estar incluído no \textit{framework}. Isto permite ao programador focar-se no desenvolvimento das funcionalidades específicas da aplicação sem ter de construir esse suporte de raiz.

Outro fator que consideramos positivo foi a integração com outras bibliotecas \textit{Python}, como o \textit{Pandas}, que usamos para o processamento de dados. Esta compatibilidade torna o desenvolvimento mais rápido e flexível, reduzindo o esforço necessário (e código) para ligar diferentes tecnologias.

Em alternativa, podíamos ter escolhido bibliotecas como \textit{Flask} \cite{grinberg2018flask} ou \textit{FastAPI} \cite{tiangolo2018fastapi}. Apesar de \textit{FastAPI} ser mais recente e mais rápido para \gls{api} \gls{rest}, o nossa aplicação, focado na transformação de dados e visualização, não necessitava de uma abordagem completamente assíncrona e não funciona totalmente com \gls{api} \gls{rest}. Já o \textit{Flask}, apesar de ser mais leve, não vem com funcionalidades como gestão de utilizadores e criação de contas, pelo que teríamos de desenvolver esses mecanismos de raiz.

Relativamente a outras opções como \textit{WordPress}, excluímos essa hipótese. O \textit{WordPress}, que é uma plataforma que suporta sites de conteúdo como blogues ou sites de notícias, não é adequado para projetos que exigem muito controlo sobre a estrutura dos dados e não integra bem com as outras tecnologias escolhidas.

\subsection{Pandas}

Para o processamento de dados, a biblioteca que decidimos usar foi o \textit{Pandas}. Esta escolha foi motivada pelo facto de ser muito utilizada em projetos de engenharia de dados, e por ser escrita em \texit{Python}.

O \textit{Pandas} permite ler e transformar ficheiros \gls{xlsx}. A sintaxe e as funcionalidades disponibilizadas para operações como normalização, filtragem, agrupamento e ordenação tornaram esta biblioteca adequada às necessidades do projeto. Uma vantagem adicional é a capacidade de converter os dados para formatos como \gls{json}, o que facilitou a sua integração com o restante da aplicação.

Apesar destas vantagens, o \textit{Pandas} não é a melhor opção se considerarmos \textit{datasets} muito grandes, uma vez que funciona inteiramente em memória. Em contextos com maiores volumes de dados, poderiam ser consideradas bibliotecas como \textit{Dask} ou \textit{Polars} por terem capacidades de paralelismo para lidar com um maior conjunto de dados (acabam por ser mais adequadas para \textit{BigData}). No entanto, para os objetivos e escala deste projeto, o \textit{Pandas} é a escolha mais equilibrada considerando o \textit{scope} do projeto que desenvolvemos.

\subsection{Plotly}

Para mostrar os gráficos da aplicação, optámos por utilizar o \textit{Plotly}, que é uma biblioteca  que permite criar visualizações, e que está disponível em várias linguagens como \texit{Python} e \texit{Javascript}. Esta escolha foi motivada pelo facto de o \textit{Plotly} suportar suportar uma \texit{API} declarativa, o que torna mais prática a integração com o \textit{frontend} e \textit{backend}, porque assim a configuração dos gráficos pode ser retornada pelo servidor, permitindo uma configuração mais estável e garantindo que todos os utilizadores vêm o mesmo tipo de gráfico. Internamente, o \textit{Plotly} utiliza uma outra biblioteca, \textit{D3.js}, que é uma biblioteca com capacidade de criar gráficos personalizados.

Além disso, a biblioteca oferece suporte a uma grande variedade de gráficos, desde gráficos de barras até formatos mais especializados como mapas de calor, o que foi importante para explorar os vários tipos de visualização poderíamos usar. Em comparação, bibliotecas como \textit{Chart.js}, embora sejam mais leves, não oferecem a mesma flexibilidade e variedade de visualizações. Por este motivo, \textit{Plotly} era a solução mais adequada para a flexibilidade e diversidade de visualizações que queríamos. O \textit{Plotly} permite criar versões da biblioteca com gráficos específicos, reduzindo bastante o tamanho do ficheiro \textit{Javascript}. Uma lista completa das diferenças pode ser consultada no capítulo \ref{ch:charts}.

A versão \textit{Python} desta biblioteca foi também importante no desenvolvimento dos gráficos, uma vez que nos permitiu explorar os dados fora da aplicação, de modo a escolher que tipo de gráfico seria o mais adequado aos dados que estávamos a analisar e que transformações eram necessárias. Este processo de exploração permitiu-nos perceber o que era possível fazer, e com a ajuda dos orientadores, definir estratégias alternativas para os conjuntos de informação que eram mais difíceis de mostrar.

\subsection{\textit{WebComponents}}

Para conseguirmos isolar a implementação dos gráficos decidimos utilizar \textit{WebComponents} \cite{webcomponents}. Esta decisão teve como base a necessidade de manter uma boa experiência e criar componentes que podiam ser reutilizados para os vários tipos de visualização. 

Os \textit{WebComponents} \cite{webcomponents} são uma especificação nativa dos \textit{browsers}, que permite definir componentes reutilizáveis com encapsulamento de estilo e comportamento. Ao evitarmos dependências pesadas como o \textit{React}, conseguimos reduzir a complexidade técnica da aplicação, mantendo ao mesmo tempo a flexibilidade e capacidade de reutilização dos componentes desenvolvidos.

Apesar de \textit{React} ser uma biblioteca muito utilizada para aplicações \textit{web}, considerámos que para este projeto, a sua introdução seria aumentar as dependências e complexidade. A alternativa escolhida é uma solução mais leve e mais fácil de manter. 

Outra razão que nos levou a esta escolha foi o facto do \textit{Django} já trazer consigo as funcionalidades de criação e gestão de contas de utilizador1, pelo que se a aplicação \textit{web} fosse escrita totalmente em \textit{React}, teríamos de usar o \textit{Django} apenas como uma \gls{api} \gls{rest}, e utilizar métodos alternativos de criação e gestão de contas de utilizador1 como \textit{OAuth2}.

\subsection{\textit{PostgreSQL}}

Para a persistência de dados, utilizámos a aplicação de gestão de bases de dados \textit{PostgreSQL} que é uma das soluções \textit{open-source} mais completas atualmente. Inicialmente foi considerada a utilização de \textit{SQLite} por simplicidade durante o desenvolvimento, mas como iriamos usar \gls{json} para armazenar dados,  decidimos que o \textit{PostgreSQL} era a melhor opção. O \textit{PostgreSQL} têm um bom desempenho, suporte a consultas mais complexas e é compatível com o \gls{orm} do \textit{Django}.

\subsection{Docker}

O \textit{Docker} foi utilizado neste projeto, tanto para desenvolvimento como para ambientes de produção. A principal vantagem é a criação de ambientes de execução consistentes e isolados, garantindo que a aplicação corre da mesma forma em diferentes máquinas, sem conflitos de dependências ou configurações, e consistente em vários sistemas operativos. 

Existem vários \textit{runtimes} compatíveis com \textit{Docker}, e devido ao modelo de negócio da empresa \textit{Docker} (que adotou um modelo pago), optámos por usar o \textit{Rancher} (uma aplicação com uma \gls{api} compatível com \textit{Docker}) para o desenvolvimento, e o \textit{Docker Engine} para ambientes de produção.

Durante o desenvolvimento, o \textit{Docker} facilitou a orquestração dos vários serviços usados (a aplicação \textit{Django}, a base de dados, e o servidor \gls{http} \textit{Nginx} configurado como \textit{reverse proxy}), através de ficheiros \texttt{Dockerfile} e \texttt{docker-compose.yml}. Isto permitiu-nos montar o ambiente da aplicação, sem necessidade de instalações manuais.

Para produção, o \textit{Docker} permite recriar um ambiente de produção sempre com a mesma configuração e gerir os vários serviços que a aplicação utiliza, o que facilita o processo de \textit{deploy}, e escalabilidade futura. Esta abordagem garante que o código testado é exatamente o que será executado em produção, reduzindo erros e aumentando a estabilidade da aplicação.

O \textit{Docker} foi também utilizado durante o desenvolvimento deste relatório, porque permitiu-nos ter um ambiente \textit{LaTex} configurado com todas as extensões apenas com um único comando no terminal sem instalar aplicações.

\section{Outras ferramentas utilizadas}
\label{sec:tools}

Além das tecnologias centrais utilizadas no projeto, foi também fundamental a utilização de um conjunto de ferramentas de suporte que facilitaram o trabalho, a organização e o desenvolvimento do projeto. As principais ferramentas utilizadas foram:

\begin{itemize}
    \item \textbf{Git \cite{git} e Github \cite{github}}: Para assegurar o controlo de versões, foi utilizado a aplicação \texit{Git}, em conjunto com a plataforma \textit{Github}. Esta combinação permitiu não só manter um histórico das alterações feitas e reverter alterações que podiam ter introduzido defeitos na aplicação

    \item \textbf{Notion \cite{notion}}: A rganização do trabalho foi feita na plataforma \textit{Notion}. Esta aplicação é prática de fácil de usar e permitiu-nos para planear as tarefas e acompanhar o progresso das diferentes fases do projeto e também tirar notas durante o desenvolvimento, que foram importantes para o desenvolvimento do relatório.

    \item \textbf{\gls{vscode}\cite{vscode}}: Como editor, foi utilizado o editor \gls{vscode}. Através da instalação de extensões, foi possível adaptar o \gls{vscode} às necessidades do projeto, melhorando a experiência de programação.
\end{itemize}

Estas ferramentas foram importantes no desenvolvimento do projeto, não só do ponto de vista técnico, mas também no que respeita à organização e planeamento do mesmo.
