%%________________________________________________________________________
%% LEIM | PROJETO
%% 2022 / 2013 / 2012
%% Modelo para relatório
%% v04: alteração ADEETC para DEETC; outros ajustes
%% v03: correção de gralhas
%% v02: inclui anexo sobre utilização sistema controlo de versões
%% v01: original
%% PTS / MAR.2022 / MAI.2013 / 23.MAI.2012 (construído)
%%________________________________________________________________________


%%________________________________________________________________________
\chapter{Implementação do Modelo}
\label{ch:implementacaoDoModelo}
%%________________________________________________________________________

Este capítulo descreve como se passou do modelo conceptual para a implementação da aplicação. O desenvolvimento foi feito de forma iterativa, com testes e validações com base nos objetivos do projeto e nos dados recebidos. Primeiro foi feita a análise e classificação dos dados, que ajudou a definir como seriam processados e que gráficos íamos usar. Depois, vamos detalhar o desenvolvimento da \textit{pipeline} de transformação e a lógica de organização de ficheiros. Por fim, é explicado como as tecnologias escolhidas foram usadas para criar a aplicação.

\section{Análise e Transformação dos dados}

O processo de análise começou após a reunião inicial com os orientadores do projeto, onde recebemos os ficheiros que iriam ser trabalhados. Tratar estes ficheiros implicou várias fases de análise, onde começamos a pensar em estratégias para conseguir extrair dados e possíveis gráficos, e tornar este processo modular.

\subsection{Análise inicial dos dados}
\label{sec:analiseInicial}

Após termos recebido os dados, fizemos uma primeira análise com o objetivo de perceber a informação recebida. No total, recebemos 30 ficheiros \gls{xlsx} que foram exportados da plataforma, correspondentes às diferentes secções da plataforma de simulação. Cada ficheiro pode conter várias folhas de cálculo, e no total contámos 101 folhas de cálculo nos ficheiros que recebemos.

Durante esta análise, percebemos que:

\begin{itemize}
    \item Os nomes dos ficheiros e das folhas variam, mas seguem uma estrutura relativamente consistente.   
    \item Alguns ficheiros apresentam estruturas de dados semelhantes, mas com diferenças no nível de detalhe ou na organização das colunas e linhas.   
    \item Existiam ficheiros com dados que iriam precisar de mais transformação uma vez que representavam vários tipos de unidades (como por exemplo percentagens, valores monetários, valores relativos, entre outros) na mesma folha de cálculo.  
    \item Dados com muito detalhe, e com várias colunas sem representação (células marcadas com "X" ou com valores nulos e fundo amarelo).  
    \item Nenhuma das folhas de cálculo indica unidades (como por exemplo percentagens, euros, entre outros), o que significa que não é possível assumir a unidade dos valores que estão a ser representados. Os ficheiros exportados são exportados exatamente como estão na plataforma de simulação, que não usa unidades numéricas.  
\end{itemize}

Com base nesta primeira análise, concluímos que seria necessário:
\begin{itemize}
    \item Fazer uma normalização da informação recebida para garantir uma utilização consistente da aplicação.
    \item Separar os vários ficheiros possíveis em grupos, de forma a identificar dados em comum que pudéssemos aplicar \textit{templates} de gráfico.
    \item Guardar os dados extraídos num formato mais prático, e que permita uma filtragem dinâmica da informação carregada (de forma a facilitar a visualização dos dados).
    \item Em algumas séries de dados, identificamos linhas e colunas que se podiam remover devido a serem redundantes (ou por representarem informação que já é representada na mesma folha, como por exemplo colunas de valores totais, linhas que repetiam as marcas, ou outras discutidas com os orientadores).
    \item Relativamente à falta de unidades, para manter a consistência com a plataforma de simulação, optámos por não assumir nenhuma unidade para os valores que estão a ser representados, uma vez que não é possível inferir a unidade dos valores a partir dos dados recebidos, a plataforma de simulação não usa unidades numéricas, e para não induzir os alunos em erro com a interpretação dos dados.
\end{itemize}

Esta primeira análise ajudou-nos a perceber como estruturar o modo como iríamos tratar os diferentes ficheiros que os utilizadores podem carregar, ou seja, deu-nos uma base para sistematizar a transformação da informação de forma consistente. Com isso em mente, optámos por agrupar os dados em várias categorias, tendo por base a estrutura de cada folha de cálculo.

\subsection{Classificação dos dados}

Os grupos definidos foram os seguintes: \textbf{simples}, \textbf{duplo}, \textbf{balanços}, \textbf{setores} e \textbf{análise específica}. Vamos então descrever o significado de cada grupo e identificar o que é comum entre os gráficos pertencentes a cada um deles.

O grupo \textbf{simples} inclui ficheiros em que a estrutura é mais direta, geralmente com apenas duas colunas: uma coluna que representa uma categoria (como por exemplo empresas ou segmentos de mercado) e uma coluna numérica. Nestes casos, optámos por gráficos de barras, uma vez que o objetivo principal é comparar rapidamente valores individuais entre categorias. Nos ficheiros que avaliamos, não encontramos séries temporais, pelo que não justificou gráficos de linhas. Também nesta categoria, alguns dados eram séries mais específicas (como dados relativos a médias e medianas) mas mantinham a mesma estrutura de dados, pelo que foram classificados como \textbf{simples} mas utilizaram gráficos diferentes como gráficos de diagramas e quartis e gráficos de setores (também conhecidos como \textit{pie charts}).

O grupo \textbf{duplo} refere-se a ficheiros onde existem múltiplas séries de dados associadas à mesma categoria. Ou seja, para cada categoria, existem vários valores (ou várias séries) que precisam de ser representados lado a lado. Para estes casos, a escolha que fizemos foi apresentar gráficos de barras agrupadas e barras empilhadas, permitindo uma comparação direta entre diferentes séries de dados para a mesma categoria, e permite visualizar todos os dados relacionados com essa categoria.

O grupo \textbf{balanços} abrange ficheiros associados a séries de dados financeiros, onde faz sentido representar aumentos e diminuições de valores ao longo de um processo ou período. Para estes ficheiros, o \textit{template} selecionado foi o gráfico de cascata (ou um gráfico \textit{financial waterfall}), dado que este tipo de visualização representa as várias componentes do valor total numa forma fácil de perceber.

O grupo \textbf{agrupados} inclui ficheiros onde conseguem ser apresentados grupos de dados associados a uma categoria (como por exemplo, para uma empresa, mostrar a presença nos segmentos de mercado por marca). Nestes casos, faz sentido usar gráficos de setores e barras agrupadas, dependendo da necessidade de comparar proporções entre segmentos.

Finalmente, o grupo de \textbf{análise específica} são ficheiros que não se encaixam diretamente nos formatos anteriores, por não partilharem de uma estrutura comum ou quando os dados incluem várias unidades na mesma folha (percentagens com euros na mesma folha de cálculo) e que precisavam de uma análise mais detalhada. Para estes casos, o processo passou por simplificar a informação de modo a encaixar num dos grupos acima ou excecionalmente aplicar um novo tipo de gráfico. Na figura \ref{fig:before} é possível ver um exemplo de um ficheiro que foi classificado como \textbf{análise específica}.

\begin{figure}[H]
\centering
\includegraphics[max width=\textwidth]{./img/before}
\caption{Excerto de uma folha de cálculo recebida}
\label{fig:before}
\end{figure}

Para casos em que a não era possível aplicar um \textit{template} de gráfico, não foi possível simplificar a informação e não encontrámos uma representação gráfica que fosse fácil de interpretar, optámos por não aplicar nenhum gráfico, e apenas apenas mostrar uma tabela interativa com os dados onde o utilizador podia filtrar os dados por diferentes colunas.

No final, dos 30 ficheiros recebidos, a classificação foi a seguinte:

\begin{figure}[h]
    \centering
    \includegraphics[max width=10cm]{./img/stats1}
 \caption{Classificação dos ficheiros - contagem final dos grupos}
 \end{figure}

Em termos de representações utilizadas, a distribuição é a seguinte:
\begin{figure}[h]
    \centering
    \includegraphics[max width=10cm]{./img/stats2}
 \caption{Classificação dos ficheiros - contagem final de representações utilizadas}
 \end{figure}


A cada grupo acima mencionado, associámos um gráfico específico, criando assim um conjunto de \textit{templates} que nos permite criar visualizações de forma programática.

\subsection{Transformação dos dados}

Com a classificação de dados feita, foi necessário desenvolver uma \textit{pipeline} de processamento que permitisse normalizar e transformar os dados dos ficheiros para um formato mais fácil de representar e para guardar na base de dados. Este processo foi desenvolvido com recurso a biblioteca \textit{Pandas}, que oferece métodos para manipulação e transformação de dados. Esta \textit{pipeline} funciona de forma assíncrona, e é chamada pelo \textit{backend} quando um ficheiro é carregado, de forma a não bloquear a interface do utilizador.

A \textit{pipeline} de processamento foi dividida em duas fases, cada uma com um objetivo específico na transformação dos dados.

\subsection{Extração e Normalização Inicial}

Nesta fase, os dados são extraídos dos ficheiros carregados e normalizados para um formato consistente:

\begin{itemize}
    \item Extração do título do gráfico a partir da primeira linha de cada folha.
    \item Extração e normalização (remover expressões como ``Q5'' do nome) da secção através do nome da folha de cálculo.
    \item Identificação de cada folha por num nome único (derivado do nome da folha de cálculo), para que possamos identificar os dados de forma única na aplicação (ou seja, um \textit{slug} que mapeia exclusivamente a uma série de dados). Este passo é importante para garantir que cada série de dados é tratada de forma única e consistente, e para conseguirmos manter uma configuração para cada série de dados.
    \item Normalização dos cabeçalhos das colunas (remoção de quebras de linha, espaços extras).
    \item Remoção de colunas baseadas na análise feita na secção \ref{sec:analiseInicial}.
    \item Normalização dos dados nas células (remoção de quebras de linha, espaços duplos).
    \item Tratamento de valores nulos e vazios (transformação para tipos compatíveis com \textit{Python})
    \item Manutenção da ordem original das colunas para preservar a estrutura dos dados. A biblioteca \textit{Pandas}. automaticamente ordena as colunas, pelo que é necessário manter a ordem original das colunas para preservar a estrutura dos dados.
    \item Transformação de dados marcados como "X" em formato binário (0/1) para indicar presença/ausência de valores.
    \item Normalização de valores decimais num valor escolhido pelo utilizador (com o valor por omissão a 9).
\end{itemize}

\subsection{Processamento Específico por Tipo}

Após a normalização inicial, os dados passam por transformações específicas baseadas no seu tipo, e no tipo de gráfico que pretendemos representar:

\begin{itemize}
    \item Aplicação de transformações específicas baseadas no tipo de gráfico identificado (financeiro, percentagens, valores relativos entre outros).
    \item Processamento para dados financeiros, incluindo cálculos de percentagens e valores relativos de outros valores (aplicar somas e subtrações como descrito na folha de cálculo).
    \item Transformação dos dados para conseguir representar categorias e a relações entre elas (como por exemplo a relação entre marcas e segmentos de mercado e cidades).
    \item Para folhas que continham múltiplos \textit{quarters}, optámos por escolher o \textit{quarter} para o qual a folha foi carregada, sendo que essa configuração pode ser trocada em código.
\end{itemize}

De forma a tornar modular toda a lógica de normalização de dados, decidimos criar configurações na aplicação que mapeiam ficheiros a gráficos e as suas transformações e outras configurações associadas a colunas que são usadas para representar os dados, sendo que cada série de dados é identificada unicamente pelo seu \textit{slug}. Esta configuração não é guardada na base de dados, e só pode ser editada em código, porque para os dados extraídos serem mostrados, precisam de ser processados de forma especifica de modo a que consigam ser representados, e a sua visualização foi pensada para ser um gráfico especifico, pelo que não era possível suportar várias representações para o mesmo conjunto de dados. 

Após os dados serem processados, já não é possível alterar a visualização dos dados, porque o processamento adapta a informação que recebe para a visualização pretendida.

\subsection{Conversão e Armazenamento dos dados}
\label{sec:armazenamentoDados}

Após o processamento dos dados ser feito, os mesmos são guardados como \gls{json} num campo \textit{JSONField} da base de dados \textit{PostgreSQL}. Estes dados guardados tentam ser os mais próximos ao dados mostrados ao utilizador, mas sem perder informação quando contem várias séries dentro do mesmo conjunto de dados (como por exemplo dados de várias marcas).

Para garantir a consistência dos dados e evitar conflitos de ficheiros com o mesmo nome a serem carregados para o mesmo \textit{quarter}, foi implementado um mecanismo que permite marcar ficheiros como processados e não processados e como correntes e não correntes. Quando um utilizador carrega um ficheiro, este é marcado como processado e como corrente, e os dados são guardados na base de dados. Quando um utilizador carrega um novo ficheiro com o mesmo nome, o novo é marcado como corrente, e o antigo é marcado como não corrente. Em nenhum momento são apagados os ficheiros nao correntes que estão guardados em disco. A aplicação tem um mecanismo em que só considera ficheiros marcados como correntes para serem mostrados ao utilizador.

Isto permite recuperar versões anteriores dos dados quando o utilizador apaga um ficheiro ou quando existe algum erro no processamento, uma vez que os dados resultantes só são marcados como correntes quando são extraídos e processados com sucessos. Esta funcionalidade não foi uma funcionalidade pensada para ser exposta diretamente ao utilizador, e não faz parte do uso normal, mas surgiu como consequência da arquitetura escolhida (ficheiros correntes e não correntes).

Este mecanismo de processamento permitiu transformar os dados extraídos dos ficheiros \gls{xlsx} em um formato estruturado e normalizado, facilitando a visualização e análise dos dados através da aplicação \textit{web}. A modularidade da \textit{pipeline} também permitiu adicionar passos de normalização conforme necessário.

No final, obtemos dados que são práticos de representar, e que podem ser facilmente utilizados pela aplicação para mostrar os gráficos como é representado na figura \ref{fig:after}.

\begin{figure}[H]
\centering
\includegraphics[max width=\textwidth]{./img/after}
\caption{Gráfico extraído da figura \ref{fig:before} com filtro aplicado para o \textit{Quarter} 5}
\label{fig:after}
\end{figure}

\section{Desenvolvimento da Aplicação \textit{web}}

Esta secção foca-se na estrutura e funcionamento da aplicação \textit{web}, e como foi desenvolvemos as funcionalidades da aplicação.

\subsection{Arquitetura do Servidor}

A aplicação \textit{web} foi desenvolvida utilizando a \textit{framework} \textit{Django} como já descrito na secção \ref{sec:fundamentos}. A arquitetura foi pensada para garantir o isolamento dos dados por utilizador e uma gestão dos ficheiros e dados processados.

\subsubsection{Modelos de Dados}

A aplicação utiliza três modelos, cada um com um papel específico na gestão e organização da informação. Estes modelos são a base da aplicação, sendo que suportam todas as funcionalidades da interface gráfica. Como o \textit{Django} utiliza um \gls{orm}, cada classe definida nos modelos representa também uma tabela na base de dados, como ilustrado na Figura~\ref{fig:er-diagram}. A classe \textit{User} é uma classe que já vem incluída com o \textit{Django}, e é utilizada para gerir os utilizadores e sessões da aplicação.

\begin{figure}[H]
    \centering
    \includegraphics[max width=10cm]{./img/er-diagram.png}
 \caption{Diagrama de entidade-relação da aplicação}
 \label{fig:er-diagram}
 \end{figure}

O nosso modelo de dados é composto por três modelos principais: \textit{Quarter}, \textit{ExcelFile} e \textit{ChartData}, cada um com um papel específico no contexto da aplicação.

\textbf{Quarter:} Representa um trimestre específico para um utilizador. Cada \textit{quarter} tem:
\begin{itemize}
    \item Um número único por utilizador.
    \item Uma precisão configurável para valores numéricos (por omissão 9 casas decimais).
    \item Um \gls{uuid} para identificação. Este \gls{uuid} é único na aplicação toda.
    \item Relação com o utilizador que o criou.
\end{itemize}

\textbf{ExcelFile:} Representa um ficheiro \textit{Excel} carregado para um \textit{quarter} específico:
\begin{itemize}
    \item Armazena o ficheiro físico em pastas organizadas por \gls{uuid}.
    \item Mantém o estado de processamento (processado ou não processado).
    \item Guarda metadados como a secção do ficheiro.
    \item Relaciona-se com o \textit{quarter} e o utilizador.
    \item Controla qual versão dos dados está ativa (corrente ou não corrente).
\end{itemize}

\textbf{ChartData:} Armazena os dados processados de cada folha do \textit{Excel}:
\begin{itemize}
    \item Guarda os dados em formato \gls{json}.
    \item Mantém a ordem original das colunas.
    \item Guarda metadados como o nome da folha e o \textit{slug} para identificar os dados unicamente.
    \item Relaciona-se com o ficheiro \textit{Excel} de origem e o utilizador.
\end{itemize}

A utilização de identificadores \gls{uuid} foi importante uma vez que, para além de identificar unicamente cada instância da entidade, faz com que não seja possível aceder aos dados só a aumentar o identificador, como se fosse o caso se o identificador fosse um número inteiro sequencial. O \textit{Django} já disponibiliza uma chave primária em cada modelo por omissão, que é um número sequencial inteiro.

A consistência é assegurada através da estrutura hierárquica dos modelos: cada \textit{Quarter} pertence unicamente a um \textit{User}, e cada \textit{ExcelFile} pertence a um \textit{Quarter}. A lógica da aplicação impede que um utilizador associe ficheiros a \textit{Quarters} que não lhe pertencem, reforçando a integridade através do controlo de permissões e da autenticação. Esta arquitetura garante que não existam associações inválidas ou dados soltos no sistema.  

A associação utilizador e \textit{quarters} foi nao só como forma de organização, mas também como para controlar o acesso. Esta relação permite à aplicação apresentar \textit{quarters} de forma independente dos ficheiros carregados, o que é útil, por exemplo, para preparar a interface mesmo antes de existirem dados disponíveis (utilizadores podem criar \textit{quarters} mesmo sem ter ficheiros carregados). Além disso, ao filtrar os \textit{quarters} diretamente pelo utilizador autenticado, garante que cada utilizador só consegue visualizar e editar os seus próprios \textit{quarters}, evitando que um aluno consiga ver dados que não foram carregados pelo mesmo.

\begin{lstlisting}[language=Python, caption={Excerto do código \textit{Python} do \textit{endpoint} para listagem de \textit{quarters} }]
class QuarterListAPIView(APIView):
    def get(self, request):
        # Obter todos os quarters do utilizador, para poder mostrar ao utilizador os quarters para onde pode carregar ficheiros
        quarters = Quarter.objects.filter(user=request.user)
        last_quarter = quarters[0]
       
        # restante código que valida parâmetros e retorna resposta JSON com os dados do quarter
\end{lstlisting}


\subsubsection{Gestão de Utilizadores}

A aplicação utiliza o mecanismo de utilizadores que já vem incluído com o \textit{Django}. Este mecanismo garante que apenas utilizadores autenticados possam aceder aos seus dados. A autenticação na aplicação é feita através de nome de utilizador e palavra-passe e as sessões são geridas pelo \textit{Django}.

Para garantir a segurança dos dados, todas as rotas que requerem autorização estão marcadas com o decorador \texttt{@login\_required}. Além disso, a aplicação isola dados dados por utilizador, garantindo que cada utilizador só possa ver os dados que carregou. Este isolamento é implementado nos modelos e pesquisas, que associa ou aplica um filtro com base no utilizador autenticado nas operações de leitura e escrita.

Os utilizadores podem criar conta na aplicação, sendo que podem criar conta para si ou para um grupo de utilizadores. A aplicação não faz distinção entre uma conta para um utilizador ou para uma conta para múltiplos utilizadores.

\subsubsection{Gestão de Ficheiros e Processamento de dados}

Para manter ficheiros carregados organizados, desenvolvemos um mecanismo que garante que os dados carregados pelos utilizadores ficam organizados em pastas. Em vez de depender apenas do nome do ficheiro (o que podia facilmente gerar conflitos ou sobreposições de nomes), a aplicação cria uma pasta com \gls{uuid} do \textit{quarter} onde foram carregados, o que garante que cada ficheiro fica junto aos ficheiros do mesmo \textit{quarter}. Para ficheiros com o mesmo nome, o \textit{Django} automaticamente acrescenta letras ao final do ficheiro de forma a garantir que o nome é único dentro de cada pasta.

Assim que um ficheiro é carregado, o processamento é iniciado recorrendo a \textit{signals}, que são eventos que são lançados quando uma instância do modelo é alterado ou criado.

Para além disso, a aplicação mantém um registo de todos os ficheiros carregados. Quando se carrega um novo ficheiro que resulta nos mesmos dados, a aplicação não apaga o anterior, como já foi descrito no capítulo~\ref{sec:armazenamentoDados}. 

\subsubsection{\textit{Endpoints} para comunicação com o cliente}

A aplicação disponibiliza um conjunto de \textit{endpoints} \gls{rest} que viabilizam a interação com a interface gráfica. A comunicação com o \texit{backend} é efetuada através de chamadas assíncronas aos \textit{endpoints}, sendo possível passar parâmetros como o \textit{quarter} selecionado e um filtro escolhido pelo utilizador. Em resposta, o \texit{backend} devolve a estrutura de dados necessária para a renderização, assegurando que cada gráfico é gerado com os dados e configurações apropriados. Estes \textit{endpoints} são rotas específicas que a interface gráfica utiliza para algumas funcionalidades:

\begin{itemize}
    \item \texttt{quarters/new/}: Permite a criação de um novo \textit{quarter}.
    \item \texttt{quarters/edit/<uuid:uuid>/}: Permite editar os detalhes de um \textit{quarter} já existente, identificado pelo seu \gls{uuid}.
    \item \texttt{quarters/delete/<uuid:uuid>/}: Permite apagar um \textit{quarter} específico.
    \item \texttt{quarters/}: Permite listar todos os \textit{quarters} do utilizador.
    \item \texttt{quarters/files/delete/<uuid:uuid>/}: Permite remover um ficheiro associado a um \textit{quarter}, usando o \gls{uuid} do ficheiro.
    \item \texttt{api/chart/}: Retorna os dados para os gráficos
  \end{itemize}
  
O \textit{endpoint} para visualização de gráficos é o mais importante, uma vez que é utilizado para mostrar os gráficos na aplicação \textit{web}, e aceita parâmetros para filtrar e mostrar gráficos de diferentes tipos. Estes \textit{endpoints} são usados com recurso a pedidos \gls{http} (utilizando \texttt{fetch}) e também como páginas que aceitam parâmetros por \gls{url} (como por exemplo em formulários através do atributo \texttt{action}).


\begin{lstlisting}[language=HTML, caption={Excerto do código \gls{html} do formulário de edição de \textit{quarter} }]
    <form method="post" action="/quarters/edit/b12fdf1f-8ce3-4050-a28f-07e444e15042/" id="edit-quarter-form" class="upload-form-wrapper" enctype="multipart/form-data">
      {% csrf_token %}
      <div class="flex justify-end">
        <button type="submit" class="upload-modal-submit-btn">Save</button>
      </div>
    </form>
    \end{lstlisting}

Quando a aplicação carrega, não mostra logo todos os gráficos, mas sim um \textit{skeleton} que depois é substituído pelo gráfico, melhorando a experiência do utilizador. Esse carregamento utiliza o \textit{endpoint} para visualização de gráficos para obter a configuração final de um gráfico especifico a ser mostrado. A configuração retornada é especifica para a biblioteca \textit{Plotly}, que depois, juntamente com o restante código \textit{Javascript}, consegue mostrar o gráfico e aplicar filtros com base nos parâmetros passados.

\subsection{Interface Gráfica}

A interface da aplicação foi desenhada com foco na consistência visual e na usabilidade, utilizando um \textit{design system}, \textit{Flowbite}. O objetivo é garantir uma aplicação responsiva, adequada para todos os ecrãs de computador e monitores e que suportasse minimamente dispositivos móveis, sem comprometer a performance nem a clareza na apresentação dos dados.

\subsubsection{\textit{Layout} e Linguagem visual}

Um \textit{design system} é uma biblioteca que oferece um conjunto de componentes reutilizáveis que podem ser usados em interfaces visuais. A escolha do \textit{Flowbite} acelerou o desenvolvimento e simplificou a criação da interface visual, e de elementos como modais, formulários e botões. 

A navegação principal é feita através de uma barra horizontal no topo da interface, que lista todas as páginas que se podem consultar e que permite os utilizadores aceder à pagina de carregamento de ficheiros. As modais são usados para operações carregamento de ficheiros. Para o desenvolvimento do \gls{css} foi utilizada a linguagem \gls{scss}, que permite desenvolver estilos de forma mais rápida e mais organizada, que depois é transpilada (através de um \textit{build system} como o \textit{ESBuild}\cite{esbuild}) para \gls{css} normal.

Quando não existe gráficos a mostrar, é mostrada ao utilizador uma mensagem que indica que não existe ficheiros carregados, com uma hiperligação a redirecionar para a página de carregamento de ficheiros. Quando já existe gráficos a mostrar, é mostrada uma barra lateral com as secções e gráficos disponiveis, onde também é possível fazer uma pesquisa por texto de forma a encontrar uma secção ou gráfico específico.

\subsubsection{WebComponents}

A camada de visualização de dados é composta por componentes \textit{web}, cada um encapsulando toda a sua a lógica, incluindo integrações com as bibliotecas \textit{Plotly} e \textit{Datatables} . Esta abordagem garante isolamento entre componentes e torna possível reutilizar o código \textit{Javascript} com diferentes tipos de gráficos. 

A especificação \textit{WebComponents}\cite{webcomponents} permite criar os nossos nós \gls{dom}, e estende as interfaces \gls{dom} já existentes. Esta funcionalidade permite criar componentes que se comportam como elementos \gls{html}, e que podem ser utilizados como tal, e que também podem receber estilos e outras propriedades e atributos e é suportada já pelos os \textit{browsers} mais usados (como pode ser consultado no site \textit{Can I Use}\cite{caniuse} que é um site que indica o suporte de uma funcionalidade em diferentes \textit{browsers}).

\begin{figure}[H]
    \centering
    \includegraphics[max width=\textwidth]{./img/caniuse}
 \caption{Tabela de suporte - \textit{WebComponents}}
 \end{figure}

Na nossa aplicação, os \textit{WebComponents} são usados como elementos \gls{html} normais, que recebem apenas o gráfico que é para mostrar. Ao carregar, fazem uma chamada a um \textit{endpoint} do \textit{backend}, que retorna a configuração do gráfico, que é utilizada para mostrar o gráfico.

\begin{figure}[H]
    \centering
    \includegraphics[max width=\textwidth]{./img/webc}
 \caption{Utilização de \textit{WebComponents} na aplicação}
 \end{figure}

A comunicação com o \textit{backend} é feita através de chamadas assíncronas aos \textit{endpoints} desenvolvidos, passando parâmetros como o \textit{quarter} selecionado e os filtros ativos. O \textit{backend} devolve a configuração do gráfico para renderização com \textit{Plotly}, assegurando que cada gráfico é gerado com os dados e configurações corretas, como pode ser observado no diagrama de sequência \ref{fig:sequence}.

\begin{figure}[H]
    \centering
    \includegraphics[max width=\textwidth]{./img/sequence}
 \caption{Diagrama de sequência da comunicação com o \textit{backend}}
 \label{fig:sequence}
\end{figure}

A biblioteca \textit{Plotly} suporta uma configuração declarativa, ou seja, apenas precisamos de retornar um objeto estático, e através dessa configuração, a biblioteca consegue criar a visualização

\begin{lstlisting}[language=Javascript, caption={Excerto de uma configuração para um gráfico com a utilização da biblioteca \textit{Plotly}}]
  var trace1 = {
    x: ['giraffes', 'orangutans', 'monkeys'],
    y: [20, 14, 23],
    name: 'SF Zoo',
    type: 'bar'
  };
  
  var data = [trace1];
  var layout = {barmode: 'stack'};
  Plotly.newPlot('myDiv', data, layout);
\end{lstlisting}

Os gráficos são carregados de forma progressiva (\textit{lazy load}). Apenas são mostrados quando entra dentro do \textit{viewport} do \textit{browser} do utilizador. O \textit{lazy load} permite que os servidor não fique sobre-carregado com pedidos, e que no lado do cliente, a memória utilizada seja minimizada visto que não são carregados todos os gráficos de uma vez.	

As bibliotecas \textit{Plotly} e \textit{Datatables} foram integradas com os \textit{WebComponents}\cite{webcomponents}, fazendo com que o \textit{WebComponent} consiga mostrar gráficos e tabelas de forma isolada. Esta integração permite que, quando o carregamento de um gráfico é iniciado, que seja apresentado  um \textit{skeleton} (uma representação visual com um \textit{spinner} e com a largura e altura aproximada de um gráfico) que é trocada pelo o gráfico em si quando os dados ficam disponíveis. A ideia deste \textit{skeleton} é que o utilizador veja que o gráfico está a ser carregado, e que não cause um grande deslocamento do gráfico na interface (\textit{layout shifting}) quando os dados estão prontos. 

A navegação entre \textit{quarters} é facilitada por setas em cada gráfico apresentado. A criação e remoção de \textit{quarters}, bem como o carregamento de ficheiros, é acompanhada por \textit{feedback} visual no momento da ação.

\subsubsection{Responsividade em dispositivos móveis}

Toda a interface foi pensada para ser utilizada em computadores devido à quantidade de gráficos que são apresentados. A interface adapta-se bem a dispositivos moveis, mas devido ao espaço disponível, não é possível garantir uma boa experiencia de utilização em dispositivos moveis. A aplicação tem, essencialmente, duas \textit{media queries}. Uma \textit{media query} que até aos 1023px (figura \ref{fig:res_1023}) que inclui \textit{smartphones} e \textit{tablets}, e uma \textit{media query} a partir dos 1024px que inclui computadores e ecrãs maiores (figura \ref{fig:res_1920}).

\begin{figure}[htbp]
    \centering
    \includegraphics[max width=\textwidth]{./img/res_1023}
 \caption{Media query até 1023px}
 \label{fig:res_1023}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[max width=\textwidth]{./img/res_1920}
 \caption{Media query a partir dos 1024px}
 \label{fig:res_1920}
\end{figure}

Estes \textit{media queries} são as mais comuns, garantindo uma boa experiência de utilização em todos os ecrãs, sendo que não tivemos de fazer código explicitamente para a aplicação se adaptar para dispositivos móveis. Os filtros permitem alterar os gráficos em tempo real, com \textit{feedback} visual imediato não sendo necessário recarregar a página. No momento em que o filtro troca, é feito um pedido a API de gráficos que retorna um novo conjunto de dados para mostrar, com a configuração do gráfico atualizada.

\subsubsection{Carregamento de ficheiros}

A organização dos dados foi pensada para refletir a lógica do projeto Marketplace Simulations. Cada utilizador pode criar múltiplos \textit{quarters} no momento em que carrega um ficheiro.

Para verificar se os ficheiros são do tipo correto, decidimos validar através do \textit{MIME type}, que é um identificador  utilizado para descrever o tipo de conteúdo de um ficheiro. Os \textit{MIME types} seguem o formato \texttt{tipo/subtipo}, como por exemplo \texttt{application/\allowbreak vnd\allowbreak.open\allowbreak xmlV formats-\allowbreak officedocument.\allowbreak spreadsheetml.\allowbreak sheet} para ficheiros \textit{Excel}. Esta abordagem permite garantir que os ficheiros carregados correspondem realmente ao formato esperado, independentemente da extensão do nome do ficheiro que pode ser facilmente manipulada. 

Ao validar o \textit{MIME type} do ficheiro, conseguimos rejeitar ficheiros com o tipo errado. No contexto deste projeto, esta verificação é importante, uma vez que apenas ficheiros \gls{xlsx} válidos devem ser processados. Durante o carregamento, a interface valida se os ficheiros são do tipo correto. Apenas ficheiros dos \textit{MIME type}  \texttt{application/vnd\allowbreak.openxmlformats\allowbreak officedocument\allowbreak.spreadsheetml\allowbreak.sheet} e \texttt{application/vnd.ms\allowbreak \textit{Excel}} são permitidos.  Assim, a validação por \textit{MIME type} contribui para a segurança e integridade da aplicação.


%%________________________________________________________________________
\chapter{Validação e Testes}
\label{ch:validacaoTestes}
%%________________________________________________________________________

A validação e testes da aplicação foram realizados através de múltiplas abordagens, garantindo uma cobertura de testes  da funcionalidade como da usabilidade da aplicação. Este capítulo descreve as diferentes estratégias de teste implementadas e os resultados obtidos.

\section{Testes de Acessibilidade}

A acessibilidade foi uma preocupação no desenvolvimento da aplicação, e para isso foram seguidas as diretrizes \gls{wcag} 2.1\cite{wcag21}, que definem critérios técnicos para tornar os conteúdos  \textit{web} mais acessíveis a todos os utilizadores. Para garantir a conformidade, recorremos a uma abordagem combinada de testes automáticos e validação manual. Entre as ferramentas utilizadas destacam-se duas principais: o \textit{Lighthouse} e o \textit{Axe}.

O \textit{Lighthouse} \cite{lighthouse}, desenvolvido pela Google, é uma ferramenta \textit{open source} que é lançada a partir das ferramentas de desenvolvimento do Chrome ou como \gls{cli}. Permite avaliar uma página \textit{web} em várias categorias, como por exemplo Performance, Acessibilidade, entre outras. A secção de acessibilidade do \textit{Lighthouse} valida, por exemplo, se os elementos têm contrastes suficientes, se os formulários estão corretamente identificadas com atributos \textit{aria-label}, se os títulos estão estruturados numa hierarquia e se os elementos interativos são acessíveis por teclado. O \textit{Lighthouse} classifica numa pontuação de 0 a 100 e destaca problemas com sugestões de como resolver.

Esta ferramenta sinalizou alguns problemas, como a falta de compressão \gls{gzip} e alguns erros de acessibilidade e \gls{seo}.

\begin{figure}[H]
\centering
\includegraphics[max width=10cm]{./img/lh_before}
\caption{Testes de acessibilidade com a ferramenta \textit{Lighthouse}}
\end{figure}

Estes problemas foram resolvidos (fazendo alterações na configuração do servidor \textit{Nginx} e no código da aplicação), e a ferramenta \textit{Lighthouse} passou a dar uma pontuação melhor nos vários critérios que avalia

\begin{figure}[H]
\centering
\includegraphics[max width=10cm]{./img/lh_after}
\caption{Testes de acessibilidade com a ferramenta \textit{Lighthouse} após as correções}
\end{figure}

Já o \textit{Axe}\cite{axe}, da empresa \textit{Deque}, é uma biblioteca de testes de acessibilidade, muito utilizada em ambientes profissionais. Pode ser usada como extensão de \textit{browser} ou integrada com ferramentas de testes automatizados. O \textit{Axe} avalia especificamente nos critérios definitos pela \gls{wcag} e reporta problemas como a ausência de nomes acessíveis, uso incorreto de \textit{landmarks} \gls{aria}, falhas de foco, ou elementos visuais sem representações textuais.

Nos primeiros testes feitos com a ferramenta \textit{Axe}, as ferramentas sinalizaram alguns problemas relativos a acessibilidade, como a falta de textos alternativos para alguns elementos visuais, e os níveis dos títulos não estavam a ser usados de forma adequada.


\begin{figure}[H]
    \centering
    \includegraphics[max width=10cm]{./img/axe}
    \caption{Testes de acessibilidade com a ferramenta \textit{Axe}}
    \end{figure}


Após resolver os problemas indicados pela ferramenta \textit{Axe}, conseguimos então melhorar a acessibilidade da aplicação, como se pode ver na imagem abaixo.

\begin{figure}[H]
\centering
\includegraphics[max width=10cm]{./img/axe_after}
\caption{Testes de acessibilidade com a ferramenta \textit{Axe} após as correções}
\end{figure}

No nosso caso, ambas as ferramentas foram utilizadas para identificar problemas diferentes, o \textit{Lighthouse} ajudou-nos a identificar problemas mais relativos a velocidade e performance e dar uma visão rápida do estado da acessibilidade da aplicação, enquanto o \textit{Axe} validou critérios mais técnicos e detetou problemas complexos de acessibilidade. Os testes foram feitos tanto em páginas com dados carregados como em estados vazios, e procurámos garantir que todas as interações essenciais da plataforma fossem acessíveis para leitores de ecrã e através de navegação apenas por teclado. Desta forma, procurámos alinhar a aplicação com boas práticas de desenvolvimento inclusivo, respeitando não só normas técnicas mas também a responsabilidade de criar interfaces acessíveis a todos.

\section{Testes Manuais}

Para complementar os testes das ferramentas acima, foi desenvolvido um conjunto de testes manuais utilizando a linguagem \textit{Gherkin} para descrever os cenários de teste. \textit{Gherkin} é uma linguagem estruturada, mas legível por humanos, que permite descrever comportamentos esperados da aplicação em forma de cenários do tipo Dado-Quando-Então. Esta abordagem facilita a comunicação entre equipas de desenvolvimento e de testes, garantindo que todos compreendam os objetivos de cada teste.

Foi pedido a cinco pessoas para executarem estes testes manualmente, com base nos cenários escritos, e no final preencherem um formulário com os resultados de cada execução, incluindo observações e eventuais desvios face ao comportamento esperado. Os cenários de teste desenvolvidos com base nos casos de utilização e requisitos da aplicação. Cada cenário foi escrito como exemplificado abaixo. Os restantes cenários foram incluídos no apêndice \ref{ch:cenariosGherkin}.

\begin{lstlisting}[language=Gherkin, caption={Excerto do código \textit{Gherkin} do cenário de teste para a criação de uma conta}]
Scenario: Creating an account
	Given I access the page 
	And I don't have an account or logged in
	Then I should see the "Create Account" link
	When I click the "Create Account" link
	Then I should be redirected to the "Create Account" form
	And I should see the username field
	And I should see the password filed
	And I should see the confirm password field
	When I fill that form
	And I click "Save"
	Then I should be redirected to the "Login" page
\end{lstlisting}

Apesar desta amostra não ser muito representativa, foi possível encontrar \textit{bugs} na aplicação, como por exemplo, a falta de alguns dados em alguns gráficos, e alguns gráficos não serem coerentes com a informação que estavam a mostrar. Estes \textit{bugs} foram corrigidos assim que foram reportados pelas pessoas que testaram a aplicação.

Juntamente com os casos de teste, foi dado um formulário aos utilizadores para que pudessem partilhar comentários e classificar a experiencia de utilização da aplicação. Para cada cenário de teste que foi dado, foi pedido então que os utilizadores respondessem as seguintes perguntas:

\begin{itemize}
    \item Consegui completar a tarefa (Sim / Não).
    \item Precisei de ajuda a completar a tarefa (Sim / Não).
    \item Achei a interface intuitiva de utiliza (classificação de 1 a 5).
    \item Comentários
\end{itemize}



No geral, os utilizadores que testaram a aplicação não encontraram problemas significativos, e a aplicação foi considerada fácil de usar e intuitiva. Em todas as secções do formulário, os participantes atribuíram classificações elevadas à facilidade de uso. Estes resultados sugerem uma curva de aprendizagem baixa e uma interação fluida com a interface.

\begin{figure}[H]
\centering
\includegraphics[max width=\textwidth]{./img/form2}
\caption{Captura de ecrã do formulário de testes manuais - Tarefa ``Carregar ficheiros''}
\label{fig:form2}
\end{figure}

Alguns comentários recolhidos destacam aspetos pontuais a melhorar, como a clareza de alguns dos passos dos testes e nomenclaturas utilizadas nos casos de testes, mas nenhum dos participantes reportou bloqueios ou frustrações relevantes na aplicação. Estes dados reforçam que a interface cumpre os princípios de usabilidade, sendo funcional, acessível e compreensível por parte dos utilizadores.

\section{Compatibilidade com Navegadores}

A compatibilidade com diferentes \textit{browsers} foi testada utilizando a plataforma \textit{BrowserStack}, que é uma ferramenta que permite testar a aplicação em múltiplos ambientes. Os testes foram realizados nas versões mais recentes dos principais \textit{browsers}:

\begin{itemize}
    \item Google Chrome (versões acima da 90).
    \item Mozilla Firefox (versões acima da 88).
    \item Microsoft Edge (versões acima da 90).
    \item Safari (versões acima da 18).
\end{itemize}

A aplicação é compatível com os \textit{browsers} testados nas versões em que validámos o seu funcionamento.

%%_______________________________________________________________________
\chapter{Conclusões e Trabalho Futuro}
\label{ch:conclusoesTrabalhoFuturo}
%%________________________________________________________________________

O desenvolvimento deste projeto resultou numa aplicação que responde às necessidades dos estudantes do \gls{iscal}. Desde o início, o objetivo foi construir uma solução prática, que facilitasse a leitura e exploração da informação, e ao mesmo tempo fosse escalável para crescer com os utilizadores e os dados.

\section{Conclusões}

Um dos pontos fortes deste projeto foi a implementação de um mecanismo para gerir ficheiros e transformar dados em gráficos. A funcionalidade de os utilizadores poderem carregar ficheiros diretamente exportados do simulador e, a partir daí, obterem gráficos, sem qualquer necessidade de formatação manual representa uma melhoria relação ao processo anterior, que era manual, demorado e propenso a erros. 

A decisão de usar \textit{Django} como base para o \textit{backend} revelou-se acertada. Além de facilitar a gestão de utilizadores, a \textit{framework} permitiu implementar arquitetura sólida, com separação entre as camadas \textit{frontend} e \textit{backend}. Os \textit{endpoints} que foram desenvolvidos permitiram uma comunicação rápida entre as várias partes da aplicação, suportando atualizações dinâmicas dos gráficos sem impacto na performance.

No lado do \textit{frontend}, optou-se por uma abordagem prática, usando bibliotecas para garantir a responsabilidade e usabilidade. A biblioteca \textit{Plotly} foi importante para criar gráficos interativos que ajudam os estudantes a interpretar os dados.

Durante o desenvolvimento surgiram alguns desafios técnicos. Um dos principais foi lidar com os dados em cada um dos ficheiros. Alguns traziam folhas com formatação irregular, nomes de colunas inconsistentes ou dados difíceis de perceber. Essas dificuldades levaram-nos a investigar a fundo como alguns dos cálculos eram feitos, e perceber as relações entre as várias colunas, e pensar na melhor maneira de conseguir representar essa informação.

Apesar da solução atual funcionar bem no contexto do projeto, poderá ser necessário alterar no futuro caso os ficheiros evoluam ou incluam novos tipos de dados. Outro ponto que pode ser melhorado é a interface de gestão de \textit{quarters}, que embora funcional, ainda exige alguma familiaridade com o conceito por parte do utilizador.

Para além do lado técnico, este projeto foi também uma excelente oportunidade de crescimento pessoal. Antes de começar, não tinha experiência prática com \textit{Django} nem com bibliotecas como \textit{Pandas}, e o contacto com estas tecnologias acabou por ser interessante. 

Em suma, este projeto mostrou como a combinação de ferramentas pode resultar numa solução com impacto na experiência de aprendizagem. A aplicação desenvolvida deixa aberta a porta para melhorias futuras e novos casos de utilização. É uma base que pode ser estendida ou adaptada a outros contextos onde a análise de dados seja um desafio.

\section{Trabalho Futuro}

Apesar de a aplicação atual já cumprir os objetivos definidos inicialmente, identificamos oportunidades de expansão que poderão ser exploradas em futuras iterações do projeto. 

\textbf{Interface e Experiência do Utilizador}

Uma das melhorias mais imediatas que podiam ser feitas é ao nível da interface. Pode-se alargar a diversidade de visualizações disponíveis, incluindo novos tipos de gráficos, sendo que é sempre importante ter em mente a experiencia de utilização. Para além disso, seria interessante permitir a criação de gráficos personalizáveis, onde cada utilizador poderia compor visualizações de acordo com os seus objetivos, e até juntar vários tipos de dados na mesma visualização.

Outro aspeto relevante prende-se com a configuração dinâmica dos gráficos. A ideia é deixar de apresentar visualizações estáticas e passar a oferecer ao utilizador a possibilidade de escolher, em tempo real, os tipos de gráfico, métricas e dimensões que pretende analisar. Esta abordagem aumentaria a flexibilidade da ferramenta.

\textbf{Análise de Dados e Otimização de Performance}

Uma outra abordagem que pode ser interessante passa pela incorporação de técnicas de análise preditiva. A utilização de modelos de regressão ou algoritmos de aprendizagem automática poderá ajudar os estudantes a identificar padrões e antecipar tendências de mercado com base nos dados da simulação.

Em paralelo, podia-se melhorar a eficiência da aplicação no processamento de dados de maior volume. Seria relevante avaliar o uso de bibliotecas com capacidade de tratar grandes quantidades de dado,  mantendo tempos de resposta aceitáveis e garantindo uma boa experiência de utilização.

\textbf{Gestão de Utilizadores e Colaboração}

Ao nível da gestão da plataforma, podia-se reforçar as funcionalidades de administração de utilizadores. Isto poderia incluir a criação de perfis diferenciados (por exemplo, docente, grupo, estudante) e mecanismos de controlo de permissões.

Adicionalmente, seria interessante introduzir funcionalidades de colaboração entre utilizadores, nomeadamente a partilha de visualizações e filtros de dados. Este tipo de funcionalidade é particularmente útil em contextos académicos, onde os trabalhos são frequentemente realizados em grupo ao longo do semestre.

\textbf{Integração com \textit{Marketplace Simulations}}

Por fim, um caminho a explorar passa pela integração direta com a plataforma \textit{Marketplace Simulations}, de onde os dados são originalmente extraídos. Uma abordagem possível seria o desenvolvimento de extensões de \textit{browser} (para \textit{Chrome}, \textit{Firefox} ou \textit{Edge}) que permitam importar automaticamente os dados para a aplicação.

De forma geral, estas propostas de melhoria mostram que o projeto pode continuar a evoluir significativamente, servindo como base para iterações futuras.