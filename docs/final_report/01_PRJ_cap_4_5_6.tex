%%________________________________________________________________________
%% LEIM | PROJETO
%% 2022 / 2013 / 2012
%% Modelo para relatório
%% v04: alteração ADEETC para DEETC; outros ajustes
%% v03: correção de gralhas
%% v02: inclui anexo sobre utilização sistema controlo de versões
%% v01: original
%% PTS / MAR.2022 / MAI.2013 / 23.MAI.2012 (construído)
%%________________________________________________________________________




%%________________________________________________________________________
\chapter{Implementação do Modelo}
\label{ch:implementacaoDoModelo}
%%________________________________________________________________________

O desenvolvimento da aplicação assentou em fundamentos sólidos tanto ao nível tecnológico como ao nível das boas práticas de engenharia de software e tratamento de dados. 

\section{Arquitetura Tecnológica}
\label{sec:tec}

A definição da arquitetura, a seleção das tecnologias e a organização dos dados foram guiadas por critérios de fiabilidade, modularidade, simplicidade de manutenção e possibilidade de evolução futura.  Nas seguintes secções especificamos que tecnologias escolhemos e quais as funções que desempenham no sistema.

\subsection{Django}

Para o desenvolvimento do backend da aplicação, optámos por usar a \textit{framework} Django. A escolha deveu-se ao facto  de o Django ser uma framework muito madura e com uma arquitetura bem formada.

Uma das principais vantagens do Django é o facto de seguir o padrão de arquitetura \gls{mvc}, o que facilita bastante a organização do sistema e a separação de responsabilidades. Para além disso, o Django oferece um \gls{orm} integrado, que permite interagir com bases de dados de forma mais intuitiva, sem necessidade de escrever \gls{sql} manualmente, e evitando algumas das falhas de segurança conhecidas como SQL Injection. Outro ponto muito forte é a gestão de utilizadores e sessões já estar incluida, facilitando assim o desenvolvimento e ajudando o programador a focar-se no desenvolvimento das funcionalidades específicas da aplicação.

Outro fator decisivo foi a integração natural com outras bibliotecas do ecossistema Python, como o \textit{Pandas}, que usamos para o processamento dos ficheiros carregados. Esta compatibilidade torna o desenvolvimento mais rápido, reduzindo a quantidade de trabalho necessário para ligar diferentes tecnologias.

Escolher Django em vez de alternativas como \textit{Flask} ou \textit{FastAPI} prendeu-se também com o contexto do projeto. Apesar de FastAPI ser mais recente e mais rápido para APIs REST, o nosso sistema, focado na transformação de dados e visualização, não necessitava de uma abordagem altamente assíncrona e não funciona totalmente com API's REST. Já o Flask, apesar de ser mais leve, implicaria uma maior responsabilidade na definição de toda a arquitetura e gestão de extensões, o que poderia aumentar a complexidade projeto.

Relativamente a outras opções como WordPress (que alguns poderiam sugerir para aplicações web), descartámos logo essa hipótese. O WordPress, ainda que muito eficaz para sites de conteúdo, não é adequado para projetos que exigem controlo total sobre a estrutura dos dados, processamento pesado no backend e integração com pipelines de ciência de dados.


\subsection{Pandas}

Para a manipulação de dados, a biblioteca escolhida foi o \textit{Pandas}. Esta escolha surgiu naturalmente, tendo em conta a sua forte integração com o ecossistema Python e o facto de ser amplamente utilizada em projetos de ciência de dados e engenharia de dados.

O Pandas permite ler, transformar e filtrar dados em ficheiros Excel com grande facilidade e poucas linhas de código. A sua sintaxe expressiva e as funcionalidades integradas para operações como normalização, filtragem, agrupamento ou ordenação tornaram-na particularmente adequada para o tipo de tarefas necessárias neste projeto.

Uma das vantagens mais importantes foi a capacidade de converter os dados diretamente para formatos como JSON, o que facilitou a sua integração com o frontend através da API.

Apesar destas vantagens, o Pandas não é a melhor opção quando falamos de datasets muito grandes, uma vez que funciona inteiramente em memória. Em contextos com maiores volumes de dados, poderiam ser consideradas bibliotecas como \textit{Dask} ou \textit{Polars} por terem capacidades de lidar com um maior fluxo de informação, como paralelismo.

No entanto, para os objetivos e escala deste projeto, o Pandas ofereceu um equilíbrio excelente entre funcionalidade, simplicidade e tempo de desenvolvimento.

\subsection{Plotly}

Para gerar os gráficos da aplicação, optámos por utilizar o \textit{Plotly}, uma biblioteca  que permite criar visualizações interativas, que está disponivel em várias linguagens como Python e Javascript. Esta escolha foi motivada pelo facto de o Plotly suportar suportar uma API declarativa, o que facilitou muito a integração com o frontend e backend, porque assim a configuração dos gráficos pode ser retornada do servidor, permitindo uma configuração dinâmica e garantindo que todos os utilizadores vêm o mesmo tipo de gráfico. Internamente, o Ploty utiliza uma outra biblioteca, D3.js, que é uma biblioteca com capacidade de criar gráficos personalizados.

Além disso, a biblioteca oferece suporte a uma grande variedade de gráficos, desde os mais comuns (barras, linhas, circulares) até formatos mais especializados (como gráficos de cascata ou mapas de calor), o que foi importante para cobrir os vários tipos de visualização pretendidos. Em comparação, bibliotecas como Chart.js, embora sejam mais leves, limitam-se a um conjunto reduzido de gráficos e oferecem menos controlo sobre detalhes avançados de visualização. Por este motivo, Plotly revelou-se uma solução mais adequada para a flexibilidade e diversidade de visualizações pretendida neste projeto. Uma lista completa das diferencas pode ser consultada no (\cf, capítulo \ref{ch:charts}).

A versão Python desta biblioteca foi também instrumental no desenvolvimento dos gráficos, uma vez que nos permitiu explorar os dados de forma independente do sistema (fora da aplicação) de modo escolher que tipo de gráfico seria o mais adequado aos dados que estavamos a analisar e que transformações eram necessárias para obter os gráficos escolhidos. 

É importante ter em consideração que o tamanho dos ficheiros JavaScript do Plotly é maior do que outras bibliotecas mais minimalistas, mas, no contexto deste projeto, a qualidade e a flexibilidade gráfica foram consideradas prioritárias.

\subsection{WebComponents}

No frontend, decidimos utilizar \textit{WebComponents}, sem recorrer a frameworks como React ou Vue. Esta decisão teve como base a necessidade de criar uma interface modular e leve, e garantir que a aplicação reage aos inputs do utilizador.

Os WebComponents são uma especificação nativa dos browsers modernos, que permite definir componentes reutilizáveis com encapsulamento de estilo e comportamento. Ao evitarmos dependências pesadas como o React, conseguimos reduzir a complexidade técnica da aplicação, mantendo ao mesmo tempo a flexibilidade e capacidade de reutilização dos componentes desenvolvidos.

Apesar de React ser uma framework muito utilizada para aplicações web,  com um ecossistema muito maduro e uma comunidade grande, considerámos que para este projeto, a sua introdução seria um excesso em termos de dependências e complexidade. A alternativa escolhida proporcionou uma solução mais leve e igualmente eficaz. Outra razão que nos levou a esta escolha foi o facto do Django já trazer consigo as funcionalidades de autenticação, pelo que se a aplicação web fosse escrita totalmente em React, teriamos de usar o Django apenas como uma API REST, e utilizar métodos alternativos de autenticação como OAuth2.

\subsection{PostgreSQL}

Para a persistência de dados, utilizámos o sistema de gestão de bases de dados \textit{PostgreSQL}, uma das soluções open-source mais completas e robustas disponíveis atualmente. Inicialmente foi considerada a utilização de SQLite por simplicidade durante o desenvolvimento, mas rapidamente a necessidade de maior escalabilidade e de suporte a funcionalidades como campos JSON, levou à adoção do PostgreSQL.

PostgreSQL oferece um excelente desempenho, suporte a operações complexas, integridade transacional e compatibilidade com o ORM do Django, o que permitiu tirar partido do modelo relacional sem abdicar da produtividade no desenvolvimento.

Comparado com outras alternativas como MySQL, o PostgreSQL destaca-se pelo seu suporte avançado a tipos de dados (JSON, arrays, enums), pela conformidade com standards SQL e pela sua fiabilidade em ambientes de produção.

Esta escolha garantiu que a aplicação tivesse uma base de dados capaz de crescer com o sistema, suportando tanto a fase académica como uma possível evolução futura para cenários reais de utilização.

\section{Docker}

O Docker foi utilizado neste projeto como solução de virtualização, tanto para desenvolvimento como para ambientes de produção. A principal vantagem da sua adoção prende-se com a criação de ambientes consistentes e isolados, garantindo que a aplicação corre da mesma forma em diferentes máquinas, sem conflitos de dependências ou configurações, e consistentemente em vários sistemas operativos.

Durante o desenvolvimento, o Docker facilitou a orquestração dos serviços necessários (como a aplicação Django, a base de dados PostgreSQL e o servidor HTTP Nginx configurado como reverse proxy), utilizando ficheiros \texttt{Dockerfile} e \texttt{docker-compose.yml}. Isto permitiu montar rapidamente o ambiente completo da aplicação, sem necessidade de instalações manuais por parte dos programadores.

Para produção, o Docker permite distribuir a aplicação como uma imagem imutável, o que facilita o processo de deploy, integração contínua e escalabilidade futura. Esta abordagem garante que o código testado é exatamente o que será executado em produção, reduzindo erros e aumentando a fiabilidade do sistema.

O Docker foi também utilizado durante o desenvolvimento deste relatório, porque permitiu ao grupo ter um ambiente LaTex configurado com todas as extensões apenas com um único comando no terminal, e permitiu-nos desenvolver mecanismos de compilação automáticos durante a escrita. 

\section{Análise dos dados}
Nesta secção iremos descrever como analisamos a informação recebida da plataforma de simulação e as decisões tomadas sobre essa informação.

\subsection{Análise inicial da informação}
Após termos recebido os dados, fizemos uma primeira análise com o objetivo de perceber a informação recebida e os próximos passos a tomar. No total, recebemos 39 ficheiros \gls{xlsx} que foram exportados da plataforma, 

\subsection{Classificação da informação}

- Falar sobre como classificamos os 39 ficheiros Excel em "buckets" e cada bucket ficou com um "template" gráfico pré-determinado
- Falar sobre cada grupo, o que significa e o que todos os gráficos partilham em comum em cada grupo.

\subsection{Visualização escolhidas para os vários grupos}
- Falar sobre os vários

\section{Processamento dos dados}
- Iniciar o tema de processamento de informação, converter informação desconhecida para um formato normalizado.

\subsection{\textit{Pipeline} de transformação dos dados}
A primeira fase de normalização segue os seguintes passos:
\begin{itemize}
    \item Extrai o nome do gráfico a partir da primeira linha de cada folha.
    \item Usa a segunda linha como cabeçalhos e normaliza os nomes (ex: substitui espaços por \textit{underscores}, remove quebras de linha).
    \item Remove colunas irrelevantes com base numa lista de columnas que não tem representação.
    \item Normaliza dados nas células (como por exemolo: remove quebras de linha, espaços duplos).
\end{itemize}

A segunda fase vai depender do ficheiro e do gráfico que queremos apresentar, mas no geral,

(...) completar isto

- Falar como foi desenvolvida, e as várias fases  de transformação A desenvolvida em \textit{Python} com recurso ao Pandas. 


\subsection{Conversão e Exportação para \gls{csv}}
- Falar sobre a transformação do pandas\n
- Falar da exportação do \gls{csv}\n
- Falar da gestão de ficheiros  \gls{csv} e \gls{xlsx}, e metodologias para não haver conflito entre ficheiros carregados\n


\section{Desenvolvimento da Aplicação Web}

Esta secção foca-se na estrutura e funcionamento da aplicação web — tanto o backend em Django como a interface construída com HTML, WebComponents e Flowbite.
\subsection{Arquitetura da aplicação Django}

    \begin{itemize}
        \item Descrever como está organizada a aplicação: os modelos principais (Quarter, ExcelFile, CSVFile), as relações entre eles e como são usados para garantir o isolamento por utilizador.
        \item Explicar o sistema de autenticação (Django Auth) e como se garantem as permissões e o acesso aos dados por utilizador.
        \item Referir também o uso do sistema de media (uploads) com UUIDs por quarter, e a criação automática das pastas.
    \end{itemize}

\subsection{Endpoints e API interna}

    Detalhar os principais endpoints utilizados: uploads, visualização de gráficos, listagem de ficheiros, etc.

    \begin{itemize}
        \item Mencionar a estrutura REST dos endpoints e como a interface os consome (por exemplo, o /api/charts/<chart_id>/<quarter>/).
        \item 
        \item Referir como se gere o estado do sistema com propriedades como \textit{is_current}, e o que acontece quando se substitui um ficheiro existente.
    \end{itemize}

\subsection{Sistema de processamento assíncrono e normalização}

    \begin{itemize}
        \item Falar sobre o \textit{run_pipeline_for_sheet}(...) do data_processing.py e como isso se encaixa com o modelo ExcelFile.
        \item 
        \item Comentar o sistema de marcação dos ficheiros como processados e o uso de flags como processed.
    \end{itemize}



    \section{Interface Gráfica e Experiência do Utilizador (Frontend)}

Aqui explicas como a interface foi pensada, as ferramentas utilizadas e como os gráficos são construídos com base nos dados enviados pelo backend.
\subsection{Design System e Flowbite}

    Explicar por que escolheste Flowbite e como ele ajudou a construir uma UI consistente e reutilizável.

    Mostrar exemplos de componentes reutilizados, como modais, botões, tabs, etc.

\subsection{WebComponents e gráficos interativos}

    Falar sobre como encapsulaste a lógica dos gráficos usando WebComponents, para evitar conflitos de JS e garantir modularidade.

    Descrever a comunicação entre os WebComponents e o backend via fetch, passando parâmetros (por exemplo, o quarter atual, ou filtros).

\subsection{Gestão de Quarters e Uploads}

    Mostrar como funciona a criação de quarters e a navegação entre diferentes trimestres (com os botões e setas).

    Explicar o fluxo de upload de ficheiros e como a interface valida o tipo de ficheiro, evita duplicações, e atualiza a visualização após carregamento.

%%________________________________________________________________________
\chapter{Validação e Testes}
\label{ch:validacaoTestes}
%%________________________________________________________________________

Validação e testes aqui \ldots; pode precisar de referir o capítulo \ref{ch:modeloProposto} ou alguma das suas secções, \eg, a secção \ref{sec:fundamentos} \ldots

Pode precisar de apresentar tabelas. Por exemplo, a tabela \ref{tab:umaTabela} apresenta os dados obtidos na experiência \ldots
\begin{table}[h]
   \centering
   \begin{tabular}{l|l|l|l}
      $c_1$ & $c_2$ & $c_3$ & $\sum_{i=1} c_i$
      \\
      \hline \hline
      $1$ & $2$ & $3$ & $6$
      \\ \hline
      $1.1$ & $2.2$ & $3.3$ & $6.6$
      \\
      \hline \hline
   \end{tabular}
\caption{Uma tabela}
\label{tab:umaTabela}
\end{table}

Para além de tabelas pode também precisar de apresentar figuras. Por exemplo, a figura \ref{fig:umafigura} descreve \ldots
\begin{figure}[h]
   \centering
   \includegraphics[width=2cm]{./fig_logo_ISEL}
\caption{Uma figura}
\label{fig:umafigura}
\end{figure}

\paragraph{Atenção.} Todas as tabelas e figuras, \eg, diagramas, imagens ilustrativas da aplicação em funcionamento, têm que ser devidamente enquadradas no texto antes de serem apresentadas e esse enquadramento inclui uma explicação da imagem apresentada e eventuais conclusões (interpretações) a tirar dessa imagem.


%%________________________________________________________________________
\chapter{Conclusões e Trabalho Futuro}
\label{ch:conclusoesTrabalhoFuturo}
%%________________________________________________________________________

Conclusões e trabalho futuro aqui \ldots

Quais as principais mensagens a transmitir ao leitor deste trabalho? O leitor está certamente interessado nos temas aqui abordados. Em geral procurará, neste projeto, pistas para algum outro objetivo. Assim, é muito importante que o leitor perceba rapidamente a relação entre este trabalho e o seu próprio (do leitor) objetivo.

Aqui é o local próprio para condensar a experiência adquirida neste projeto e apresentá-la a outros (futuros leitores).

O pressuposto é o de que de que este projeto é um \aspas{elemento vivo} que recorreu a outros elementos (\cf, capítulo \ref{ch:trabalhoRelacionado}) para ser construído e que poderá servir de suporte à construção de futuros projetos.








